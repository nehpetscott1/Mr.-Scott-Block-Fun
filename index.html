<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Mr. Scott's Block Fun — Classroom Edition</title>
<meta name="description" content="Educational Tetris with learning analytics for classroom data literacy"/>

<!-- Self-hosted fonts fallback -->
<link rel="preconnect" href="https://fonts.googleapis.com"/>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
<link href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet"/>

<style>
:root{
  --bg-url: none;
  --ink:#12ffb0; --cyan:#07e1ff; --amber:#ffb000; --violet:#7a5cff; --space:#070a16;
  --panel:#0e1322; --accent:#17fbd0; --crt:#00ff9d;
  /* Default piece colors */
  --cI: #00e5ff; --cO: #ffd900; --cT: #9d63ff; --cS: #15ff76; --cZ: #ff4b4b; --cJ: #4a74ff; --cL: #ff9a2b;
}

/* Colorblind-friendly palette (Deuteranopia/Protanopia optimized) */
body.colorblind {
  --cI: #00d4ff; /* Brighter cyan */
  --cO: #ffea00; /* Enhanced yellow */
  --cT: #b84dff; /* Magenta shift */
  --cS: #00ff88; /* Keep green */
  --cZ: #ff5050; /* Keep red */
  --cJ: #5588ff; /* Deeper blue */
  --cL: #ff8800; /* Pure orange */
}

*{box-sizing:border-box;margin:0;padding:0}
body{
  font-family:'JetBrains Mono','Courier Prime',monospace;
  background:var(--space); color:#bdfbe8; min-height:100vh; padding:1rem; overflow-x:hidden;
  transition:filter .3s ease;
}

/* BG stack */
.mc-bg{position:fixed; inset:0; z-index:-2; pointer-events:none}
.mc-art{
  position:absolute; inset:-2%;
  background: radial-gradient(120% 120% at 50% 10%, rgba(5,12,22,.9), rgba(3,8,16,1)), var(--bg-url);
  background-position:center; background-size:cover; background-repeat:no-repeat;
  image-rendering:auto; filter:saturate(1.02) contrast(1.02) brightness(.95);
  transition:opacity .6s ease; opacity:1;
}
.mc-art.is-fading{opacity:0}

/* Respect motion preferences */
@media (prefers-reduced-motion: no-preference) {
  .mc-aurora{ animation:mcAurora 14s ease-in-out infinite alternate; }
  @keyframes mcAurora{ 0%{transform:none} 100%{transform:translate(-2%,2%) scale(1.04)} }
  .cell.g.lp{ animation:ghostPulse .35s ease-in-out infinite alternate; }
  @keyframes ghostPulse{ from{opacity:.55} to{opacity:.85} }
  .rowflash{ animation:rowFlash .18s ease-in-out 2; }
  @keyframes rowFlash{ 0%{background:#000} 50%{background:#97ffd3} 100%{background:#000} }
}

.mc-aurora{
  position:absolute; inset:-10%;
  background:
    radial-gradient(40% 60% at 20% 10%, rgba(122,92,255,.25) 0%, transparent 60%),
    radial-gradient(48% 58% at 80% 0%, rgba(7,225,255,.18) 0%, transparent 60%),
    radial-gradient(46% 62% at 80% 80%, rgba(18,255,176,.16) 0%, transparent 70%);
  filter:blur(28px) saturate(120%);
}
.mc-vignette{position:absolute; inset:0; background: radial-gradient(120% 120% at 50% 25%, transparent 55%, rgba(0,0,0,.45) 90%), radial-gradient(100% 100% at 50% 120%, rgba(0,0,0,.55), transparent 50%); mix-blend-mode:multiply}
.mc-watermark{position:absolute; right:12px; bottom:10px; font-weight:800; letter-spacing:.25rem; font-size:.75rem; color:rgba(18,255,176,.22); text-shadow:0 0 8px rgba(18,255,176,.25); user-select:none}

/* Layout */
.container{max-width:1200px; margin:0 auto}
.title{ text-align:center; font-size:2.2rem; font-weight:900; letter-spacing:.2rem; margin:.25rem 0 1rem;
  color:#e8fff7; text-shadow:0 0 12px var(--accent), 0 0 24px rgba(23,251,208,.25);
}
.subtitle{ text-align:center; margin:-.5rem 0 1rem; color:#89ffe0; font-size:.9rem; opacity:.9}
.game-layout{display:grid; grid-template-columns:1fr auto 1fr; gap:1.25rem; align-items:start}
.side-panel{
  background:linear-gradient(180deg, rgba(12,18,32,.75), rgba(8,12,24,.75));
  border:2px solid rgba(23,251,208,.55); border-radius:10px; padding:1rem;
  box-shadow:0 0 18px rgba(23,251,208,.18), inset 0 0 22px rgba(0,0,0,.35)
}
.panel-title{font-weight:800; text-align:center; color:#cafff1; margin:0 0 .6rem; font-size:1.05rem}
.kv{display:flex; justify-content:space-between; margin:.25rem 0; font-size:.9rem}
.kv .v{color:#9ff; font-weight:800}

/* Board */
.board{
  width:320px; height:640px; border:4px solid rgba(23,251,208,.8); border-radius:8px;
  background:radial-gradient(120% 120% at 50% 10%, rgba(5,12,22,.92), rgba(3,8,16,.98));
  box-shadow:0 0 24px rgba(18,255,176,.28), inset 0 0 24px rgba(18,255,176,.07), 0 0 80px rgba(7,225,255,.06);
  display:grid; grid-template-columns:repeat(10,1fr); grid-template-rows:repeat(20,1fr); gap:1px; padding:4px; justify-self:center; touch-action:none
}
.cell{background:#000; border:1px solid #1a2a44; transition:background-color .08s ease, box-shadow .12s ease, opacity .12s ease}
.cell.f{box-shadow:inset 0 0 12px rgba(255,255,255,.27)}
.cell.g{background:#044!important; opacity:.5}
.cell.g.lp{background:#0a7!important; opacity:.75}

/* Mini previews */
.mini{width:96px; height:96px; border:2px solid #044; border-radius:4px; background:#000; display:grid; grid-template-columns:repeat(4,1fr); grid-template-rows:repeat(4,1fr); gap:1px; padding:4px; margin:.25rem auto}
.pxc{background:#000; border-radius:1px}
.minilist{display:grid; gap:.4rem; justify-items:center}

/* Buttons */
.btn{ background: rgba(10,16,28,.85); border:2px solid rgba(23,251,208,.55); color:#bdfbe8;
  padding:.6rem .8rem; border-radius:6px; font-family:inherit; font-size:.9rem; font-weight:800; cursor:pointer; transition:.15s; text-transform:none
}
.btn:hover:not(:disabled){ background: rgba(12,20,36,1); border-color: var(--cyan); box-shadow: 0 0 12px rgba(7,225,255,.35) }
.btn:focus{ outline:2px solid var(--cyan); outline-offset:2px }
.btn:disabled{opacity:.5; cursor:not-allowed}
.btn.alt{border-color:#7a5cff; color:#e7e0ff}
.row{display:flex; gap:.5rem; flex-wrap:wrap}
.small{font-size:.8rem; opacity:.9}

/* Keybinds / options */
.grid2{display:grid; grid-template-columns:auto 1fr; gap:.4rem .5rem; align-items:center}
.input, select{ background:#0b0f1d; color:#cafff1; border:1px solid #044; border-radius:4px; padding:.35rem .5rem; font-family:inherit; font-size:.85rem }

/* Modals */
.modal{ position:fixed; inset:0; background:rgba(0,0,0,.9); display:flex; align-items:center; justify-content:center; z-index:1000; padding:1rem }
.box{ background:#111; border:4px solid var(--crt); border-radius:10px; padding:1.2rem; width:min(720px, 92vw); color:#dbfff2; text-align:center; box-shadow:0 0 30px rgba(0,255,157,.35) }
.h1{font-size:1.6rem; font-weight:900; margin-bottom:.5rem}
.h2{font-size:1.1rem; font-weight:800; margin:.6rem 0}
.hidden{display:none!important}

/* Colors for blocks */
.cI{background:var(--cI)!important}
.cO{background:var(--cO)!important}
.cT{background:var(--cT)!important}
.cS{background:var(--cS)!important}
.cZ{background:var(--cZ)!important}
.cJ{background:var(--cJ)!important}
.cL{background:var(--cL)!important}

/* Toast / banners */
.toast{ position:fixed; top:10px; left:50%; transform:translateX(-50%); background:#03161a; border:2px solid #2affd2; color:#d5fff6; padding:.4rem .7rem; border-radius:6px; font-weight:900; box-shadow:0 0 16px rgba(0,255,170,.25); z-index:1100; opacity:0; transition:.25s }
.toast.show{opacity:1}

/* Live stats overlay */
.live-stats{
  position:fixed; top:1rem; right:1rem; background:rgba(5,12,22,.85); border:2px solid rgba(23,251,208,.4);
  border-radius:6px; padding:.5rem .7rem; font-size:.75rem; z-index:999; min-width:140px;
  box-shadow:0 0 12px rgba(18,255,176,.15);
}
.live-stats .row{display:flex; justify-content:space-between; gap:1rem; margin:.15rem 0}

/* Responsive */
@media (max-width:1024px){ 
  .game-layout{ grid-template-columns:1fr; gap:1rem } 
  .board{ width:280px; height:560px }
  .live-stats{ top:auto; bottom:1rem; font-size:.7rem; min-width:120px }
}
</style>
</head>
<body>
<!-- BG -->
<div class="mc-bg">
  <div class="mc-art"></div>
  <div class="mc-aurora"></div>
  <div class="mc-vignette"></div>
  <div class="mc-watermark">MR. SCOTT</div>
</div>

<!-- Live stats overlay -->
<div class="live-stats hidden" id="liveStats">
  <div style="font-weight:900; text-align:center; margin-bottom:.3rem; color:#9ff">LIVE</div>
  <div class="row"><span>LPM:</span><span id="liveLpm">0</span></div>
  <div class="row"><span>B2B:</span><span id="liveB2b">—</span></div>
  <div class="row"><span>Combo:</span><span id="liveCombo">—</span></div>
</div>

<div class="container">
  <h1 class="title">MR. SCOTT'S BLOCK FUN</h1>
  <p class="subtitle">A classroom falling-blocks lab for algorithms, UX, and data literacy.</p>

  <div class="game-layout">
    <!-- LEFT: score/next/hold -->
    <div class="side-panel">
      <div class="panel-title">SCORE</div>
      <div class="kv"><span>Score</span><span class="v" id="uiScore" aria-live="polite">0</span></div>
      <div class="kv"><span>Lines</span><span class="v" id="uiLines" aria-live="polite">0</span></div>
      <div class="kv"><span>Level</span><span class="v" id="uiLevel" aria-live="polite">1</span></div>

      <div class="panel-title" style="margin-top:.8rem">HOLD</div>
      <div class="mini" id="holdMini" role="img" aria-label="Hold piece preview"></div>

      <div class="panel-title" style="margin-top:.8rem">NEXT</div>
      <div class="minilist" id="nextList" role="img" aria-label="Next pieces preview">
        <div class="mini"></div><div class="mini"></div><div class="mini"></div><div class="mini"></div><div class="mini"></div>
      </div>
    </div>

    <!-- CENTER: board -->
    <div class="board" id="board" role="region" aria-label="Game board"></div>

    <!-- RIGHT: controls & teacher pane -->
    <div class="side-panel">
      <div class="panel-title">CONTROLS</div>
      <div class="row">
        <button class="btn" id="btnStart" aria-label="Start game">Start</button>
        <button class="btn" id="btnPause" disabled aria-label="Pause game">Pause</button>
        <button class="btn" id="btnRotate" aria-label="Rotate piece">Rotate</button>
        <button class="btn" id="btnDrop" aria-label="Hard drop piece">Hard Drop</button>
        <button class="btn alt" id="btnHold" aria-label="Hold piece">Hold</button>
      </div>

      <div class="h2">Options</div>
      <div class="grid2 small" style="margin:.4rem 0 0">
        <label for="studentId">Student ID</label><input class="input" id="studentId" placeholder="e.g., 3A-17"/>
        <label for="queueSize">Queue Size</label>
        <select id="queueSize" class="input" aria-label="Next pieces queue size"><option>5</option><option>4</option><option>3</option></select>
        <label><input type="checkbox" id="optGhost" checked/> Ghost</label><span></span>
        <label><input type="checkbox" id="optAdaptive" checked/> Adaptive mode</label><span></span>
        <label><input type="checkbox" id="optSymbolic"/> Symbolic boost</label><span></span>
        <label><input type="checkbox" id="optDaily"/> Daily Seed</label><span></span>
        <label for="seed">Seed</label><input type="number" id="seed" class="input" min="0" step="1" value="0"/>
        <label for="lock">Lock Delay (ms)</label><input type="number" id="lock" class="input" min="0" step="10" value="500"/>
        <label><input type="checkbox" id="optMusic" checked/> Music</label><span></span>
        <label><input type="checkbox" id="optSfx" checked/> SFX</label><span></span>
        <label><input type="checkbox" id="optColorblind"/> Colorblind palette</label><span></span>
        <label><input type="checkbox" id="optReducedMotion"/> Reduced motion</label><span></span>
      </div>

      <div class="h2">Teacher</div>
      <div class="row">
        <button class="btn" id="btnExport" aria-label="Export session data as CSV">Export CSV</button>
        <button class="btn" id="btnResetData" aria-label="Clear local storage data">Clear Local Data</button>
      </div>
      <p class="small" style="margin-top:.4rem">
        Metrics: LPM, latency, inputs, soft/hard drops, mis-rotates, locks, T-Spins, Perfect Clears, combos, B2B.
      </p>
      <div class="small" id="teacherStats" style="margin-top:.4rem; line-height:1.5"></div>
    </div>
  </div>
</div>

<!-- Modals -->
<div class="modal" id="modalStart" role="dialog" aria-labelledby="startTitle" aria-modal="true">
  <div class="box">
    <div class="h1" id="startTitle">Mr. Scott's Block Fun</div>
    <p class="small" style="margin:.4rem 0 1rem">Press <b>Space/Enter</b> or click <b>Start</b>.</p>
    <div class="row" style="justify-content:center">
      <button class="btn" id="btnOpenTutorial" aria-label="Open tutorial">Tutorial</button>
      <button class="btn" id="btnDoStart" aria-label="Start game">Start Game</button>
    </div>
  </div>
</div>

<div class="modal hidden" id="modalOver" role="dialog" aria-labelledby="overTitle" aria-modal="true">
  <div class="box">
    <div class="h1" id="overTitle">Game Over</div>
    <div class="row" style="justify-content:center; margin:.4rem 0 1rem">
      <div>Score: <b id="ovScore">0</b></div>
      <div>Lines: <b id="ovLines">0</b></div>
      <div>Level: <b id="ovLevel">1</b></div>
      <div>LPM: <b id="ovLpm">0</b></div>
    </div>
    <button class="btn" id="btnAgain" aria-label="Play again">Play Again</button>
  </div>
</div>

<!-- Tutorial Modal -->
<div class="modal hidden" id="modalTutorial" role="dialog" aria-labelledby="tutTitle" aria-modal="true">
  <div class="box" style="text-align:left; max-width:600px">
    <div class="h1" id="tutTitle" style="text-align:center">Tutorial</div>
    <div id="tutorialContent" style="margin:1rem 0; min-height:180px; line-height:1.6"></div>
    <div class="row" style="justify-content:space-between; align-items:center">
      <button class="btn" id="tutPrev" aria-label="Previous tutorial slide">← Back</button>
      <span id="tutProgress" class="small" style="opacity:.7"></span>
      <button class="btn" id="tutNext" aria-label="Next tutorial slide">Next →</button>
    </div>
  </div>
</div>

<div class="toast" id="toast" role="alert" aria-live="assertive"></div>

<script>
"use strict";
/* =========================
   CONFIG + ASSETS
========================= */
const ASSETS = {
  // Placeholder paths - replace with your actual audio/image files
  music: {
    chill:  "audio/pixel-paradise-358340.mp3",
    mid:    "audio/pixel-fantasia-355123.mp3",
    rush:   "audio/pixel-rush-8-bit-chiptune-background-music-410043.mp3",
    party:  "audio/pixel-party-218705.mp3",
    over:   "audio/game-296273.mp3"
  },
  worlds: [
    { lvl: 1,  url:"img/lavender.webp" },
    { lvl: 3,  url:"img/aurora.webp" },
    { lvl: 5,  url:"img/uluru.webp" },
    { lvl: 7,  url:"img/zhangjiajie.webp" },
    { lvl: 9,  url:"img/monument-valley.webp" },
    { lvl: 11, url:"img/denali.webp" },
    { lvl: 13, url:"img/james-bond-island.webp" },
    { lvl: 15, url:"img/oludeniz.webp" },
    { lvl: 17, url:"img/maui-road.webp" },
    { lvl: 19, url:"img/guilin.webp" }
  ]
};

// Gameplay tuning
const BOARD_W = 10, BOARD_H = 20;
const INITIAL_SPEED_MS = 500;
let LOCK_DELAY = 500;
const LOCK_RESET_MAX = 15;
const DAS_MS = 170, ARR_MS = 30;
const ARE_MS = 200;
const LINE_CLEAR_DELAY_MS = 200;
const PERFECT_CLEAR_BONUS = 1800;
const SCORE_LINE = [0,100,300,500,800];
const TSPIN_BONUS = { mini:100, full:400 };
const COMBO_STEP = 50; 
const B2B_MULT = 1.5;
const SOFT_POINT = 1, HARD_POINT = 2;

// Gravity curve (Guideline-ish ms per row)
const GRAVITY_MS = {1:800,2:720,3:630,4:550,5:470,6:390,7:310,8:230,9:190,10:170,11:150,12:130,13:120,14:110,15:100,16:90,17:80,18:70,19:60,20:50};
function gravityInterval(){ return GRAVITY_MS[Math.min(20, state.level|0)] ?? 50; }

// Tetromino definitions
const TET = {
  I:{shape:[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], class:'cI', id:1},
  O:{shape:[[1,1],[1,1]], class:'cO', id:3},
  T:{shape:[[0,1,0],[1,1,1],[0,0,0]], class:'cT', id:2},
  S:{shape:[[0,1,1],[1,1,0],[0,0,0]], class:'cS', id:4},
  Z:{shape:[[1,1,0],[0,1,1],[0,0,0]], class:'cZ', id:5},
  J:{shape:[[1,0,0],[1,1,1],[0,0,0]], class:'cJ', id:6},
  L:{shape:[[0,0,1],[1,1,1],[0,0,0]], class:'cL', id:7}
};
const TYPES = Object.keys(TET);

// SRS kicks
const SRS_JLSTZ = {
  '0>1':[[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
  '1>0':[[0,0],[1,0],[1,1],[0,-2],[1,-2]],
  '1>2':[[0,0],[1,0],[1,1],[0,-2],[1,-2]],
  '2>1':[[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
  '2>3':[[0,0],[1,0],[1,-1],[0,2],[1,2]],
  '3>2':[[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
  '3>0':[[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
  '0>3':[[0,0],[1,0],[1,-1],[0,2],[1,2]]
};
const SRS_I = {
  '0>1':[[0,0],[-2,0],[1,0],[-2,1],[1,-2]],
  '1>0':[[0,0],[2,0],[-1,0],[2,-1],[-1,2]],
  '1>2':[[0,0],[-1,0],[2,0],[-1,-2],[2,1]],
  '2>1':[[0,0],[1,0],[-2,0],[1,2],[-2,-1]],
  '2>3':[[0,0],[2,0],[-1,0],[2,-1],[-1,2]],
  '3>2':[[0,0],[-2,0],[1,0],[-2,1],[1,-2]],
  '3>0':[[0,0],[1,0],[-2,0],[1,2],[-2,-1]],
  '0>3':[[0,0],[-1,0],[2,0],[-1,-2],[2,1]]
};

// DOM
const el = id => document.getElementById(id);
const boardEl = el('board'), holdMini = el('holdMini'), nextList = el('nextList');
const uiScore = el('uiScore'), uiLines = el('uiLines'), uiLevel = el('uiLevel');
const studentId = el('studentId'), queueSizeSel = el('queueSize'), lockInput = el('lock');
const optGhost = el('optGhost'), optAdaptive = el('optAdaptive'), optSymbolic = el('optSymbolic');
const optDaily = el('optDaily'), seedInput = el('seed'), optMusic = el('optMusic'), optSfx = el('optSfx');
const optCB = el('optColorblind'), optRM = el('optReducedMotion');
const btnStart = el('btnStart'), btnPause = el('btnPause'), btnRotate = el('btnRotate'), btnDrop = el('btnDrop'), btnHold = el('btnHold');
const btnExport = el('btnExport'), btnResetData = el('btnResetData');
const modalStart = el('modalStart'), btnDoStart = el('btnDoStart'), btnOpenTutorial = el('btnOpenTutorial');
const modalOver = el('modalOver'), btnAgain = el('btnAgain'), ovScore = el('ovScore'), ovLines = el('ovLines'), ovLevel = el('ovLevel'), ovLpm = el('ovLpm');
const modalTutorial = el('modalTutorial'), tutPrev = el('tutPrev'), tutNext = el('tutNext'), tutProgress = el('tutProgress'), tutorialContent = el('tutorialContent');
const teacherStats = el('teacherStats'), toastEl = el('toast');
const liveStats = el('liveStats'), liveLpm = el('liveLpm'), liveB2b = el('liveB2b'), liveCombo = el('liveCombo');
const art = document.querySelector('.mc-art');

/* =========================
   STATE
========================= */
let cells = [];
let state = {};
let queue = [];
let canHold = true;
let lockSince = null, lockResets = 0;
let lastRotate = false;
let loopRAF = 0, lastTs = performance.now();
let areUntilTs = 0;
let rngSeed = (Math.random()*1e9>>>0);
let b2bActive = false, comboCount = -1;
let sessionStart = Date.now();
const stats = { tspins:0, perfects:0 };
const roll = { inputs:0, soft:0, hard:0, mis:0, locks:0, lastInputAt:performance.now(), meanLatency:0 };
const CLASS_KEY = 'msbf_classlog';

// Horizontal repeat (DAS/ARR)
const input = { left:false, right:false, down:false, lastDir:0, das:0, arr:0 };
// ARE input buffer
let buffered = { rot:false, hold:false, dir:0 };

/* =========================
   AUDIO
========================= */
const music = {
  chill: new Audio(ASSETS.music.chill),
  mid:   new Audio(ASSETS.music.mid),
  rush:  new Audio(ASSETS.music.rush),
  party: new Audio(ASSETS.music.party),
  over:  new Audio(ASSETS.music.over)
};
Object.values(music).forEach(a=>{ a.loop=true; a.volume=.25; });
music.over.loop = false; // game-over sting should not loop

// Lightweight SFX with WebAudio; fallback to no-op if unavailable
let AC=null; 
function ac(){ 
  if(!AC){ 
    try{
      AC=new (window.AudioContext||window.webkitAudioContext)();
    }catch{
      console.warn('AudioContext not supported');
    } 
  } 
  return AC; 
}
function beep(freq=440, dur=.06, gain=.03){
  if(!optSfx.checked) return; 
  try{ 
    const ctx=ac(); 
    if(!ctx) return; 
    const o=ctx.createOscillator(), g=ctx.createGain(); 
    o.type='square'; 
    o.frequency.value=freq; 
    g.gain.value=gain; 
    o.connect(g); 
    g.connect(ctx.destination); 
    const t=ctx.currentTime; 
    o.start(t); 
    o.stop(t+dur);
  }catch(e){
    console.warn('Audio error:', e);
  }
}
const SND = {
  rotate: ()=>beep(740,.05,.02),
  move:   ()=>beep(520,.03,.02),
  drop:   ()=>beep(960,.05,.03),
  line:   ()=>beep(420,.06,.03),
  tspin:  ()=>beep(300,.12,.05),
  pc:     ()=>beep(220,.18,.06),
  combo:  ()=>beep(680,.05,.03),
  b2b:    ()=>beep(250,.12,.05),
  over:   ()=>beep(150,.25,.06)
};
function stopMusic(){ Object.values(music).forEach(a=>{a.pause(); a.currentTime=0;}); }
function playMusicForLevel(l){ 
  if(!optMusic.checked) return; 
  stopMusic(); 
  (l<5?music.chill:(l<12?music.mid:music.rush)).play().catch(e=>console.warn('Music play blocked:', e)); 
}

/* =========================
   HELPERS
========================= */
function toast(msg, ms=950){ 
  toastEl.textContent=msg; 
  toastEl.classList.add('show'); 
  setTimeout(()=>toastEl.classList.remove('show'), ms); 
}
function dailySeed(){ 
  const d=new Date(); 
  return (d.getFullYear()*10000 + (d.getMonth()+1)*100 + d.getDate())>>>0; 
}
function xs32(){ 
  rngSeed^=rngSeed<<13; 
  rngSeed^=rngSeed>>>17; 
  rngSeed^=rngSeed<<5; 
  return (rngSeed>>>0)/0xffffffff; 
}
function newBag(){ 
  const arr=[1,2,3,4,5,6,7]; 
  for(let i=arr.length-1;i>0;i--){ 
    const j=Math.floor(xs32()*(i+1)); 
    [arr[i],arr[j]]=[arr[j],arr[i]]; 
  } 
  return arr.map(id=>TYPES.find(k=>TET[k].id===id)); 
}
function makeBoard(){
  boardEl.innerHTML=''; 
  cells=[]; 
  state.board=Array.from({length:BOARD_H},()=>Array(BOARD_W).fill(null));
  const frag=document.createDocumentFragment();
  for(let y=0;y<BOARD_H;y++) {
    for(let x=0;x<BOARD_W;x++){ 
      const c=document.createElement('div'); 
      c.className='cell'; 
      frag.appendChild(c); 
      cells.push(c); 
    }
  }
  boardEl.appendChild(frag);
}
function spawn(type){ 
  const d=TET[type]; 
  return { 
    type, 
    class:d.class, 
    o:0, 
    shape:d.shape.map(r=>r.slice()), 
    x:Math.floor(BOARD_W/2)-Math.floor(d.shape[0].length/2), 
    y:-1 
  }; 
}
function cellsOf(p){ 
  const a=[]; 
  for(let y=0;y<p.shape.length;y++) {
    for(let x=0;x<p.shape[y].length;x++) {
      if(p.shape[y][x]) a.push({x:p.x+x,y:p.y+y}); 
    }
  }
  return a; 
}
function validAt(board,p,X,Y,shape=null){ 
  const sh=shape||p.shape; 
  for(let y=0;y<sh.length;y++) {
    for(let x=0;x<sh[y].length;x++) {
      if(sh[y][x]){ 
        const nx=X+x, ny=Y+y; 
        if(nx<0||nx>=BOARD_W||ny>=BOARD_H) return false; 
        if(ny>=0 && board[ny][nx]) return false; 
      } 
    }
  }
  return true; 
}
function rotCW(shape){ 
  const r=shape.length, c=shape[0].length;
  const out=Array.from({length:c},()=>Array(r).fill(0)); 
  for(let i=0;i<r;i++) {
    for(let j=0;j<c;j++) {
      out[j][r-1-i]=shape[i][j]; 
    }
  }
  return out; 
}
function srsRotateCW(p){
  const from=p.o, to=(p.o+1)&3, cand=rotCW(p.shape);
  if(p.type==='O'){ 
    if(validAt(state.board,p,p.x,p.y,cand)) return {ok:true,x:p.x,y:p.y,shape:cand,o:to,k:false}; 
    return {ok:false}; 
  }
  const table=p.type==='I'?SRS_I:SRS_JLSTZ, kicks=table[`${from}>${to}`];
  for(const [dx,dy] of kicks){ 
    const nx=p.x+dx, ny=p.y+dy; 
    if(validAt(state.board,p,nx,ny,cand)) return {ok:true,x:nx,y:ny,shape:cand,o:to,k:!(dx===0&&dy===0)}; 
  }
  return {ok:false};
}
function ghostY(board,p){ 
  let y=p.y; 
  while(validAt(board,p,p.x,y+1)) y++; 
  return y; 
}
function miniGrid(el,shape,cls){ 
  if(!el) return;
  el.innerHTML=''; 
  for(let y=0;y<4;y++) {
    for(let x=0;x<4;x++){ 
      const e=document.createElement('div'); 
      e.className='pxc'; 
      if(shape?.[y]?.[x]) e.classList.add(cls); 
      el.appendChild(e); 
    } 
  }
}
function drawHold(){ 
  const h=state.hold?TET[state.hold.type]:null;
  const sh=h?h.shape:[[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]; 
  miniGrid(holdMini,sh,h?h.class:''); 
}
function drawNext(){ 
  const minis=[...nextList.querySelectorAll('.mini')]; 
  for(let i=0;i<minis.length;i++){ 
    const t=queue[i], d=t?TET[t]:null; 
    const blank=[[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]; 
    miniGrid(minis[i], d?d.shape:blank, d?d.class:''); 
    minis[i].style.display=i<(state.queueSize||5)?'grid':'none'; 
  } 
}
function applyWorld(level=1){ 
  const w=ASSETS.worlds.reduce((b,c)=> (c.lvl<=level && (!b||c.lvl>b.lvl))?c:b, null); 
  if(!w) return; 
  art.classList.add('is-fading'); 
  setTimeout(()=>{ 
    document.documentElement.style.setProperty('--bg-url', `url("${w.url}")`); 
    art.classList.remove('is-fading'); 
  }, 280); 
}
function updateDisplay(){
  for(const c of cells) c.className='cell';
  for(let y=0;y<BOARD_H;y++) {
    for(let x=0;x<BOARD_W;x++){ 
      const cls=state.board[y][x]; 
      if(cls){ cells[y*BOARD_W+x].className='cell f '+cls; } 
    }
  }
  if(state.ghost && state.cur){ 
    const gy=ghostY(state.board,state.cur); 
    for(const {x,y} of cellsOf({...state.cur,y:gy})) {
      if(y>=0){ 
        const idx=y*BOARD_W+x; 
        cells[idx].classList.add('g'); 
        if(lockSince!==null) cells[idx].classList.add('lp'); 
      }
    }
  }
  if(state.cur){ 
    for(const {x,y} of cellsOf(state.cur)) {
      if(y>=0){ 
        cells[y*BOARD_W+x].className='cell f '+state.cur.class; 
      }
    }
  }
  uiScore.textContent=state.score; 
  uiLines.textContent=state.lines; 
  uiLevel.textContent=state.level;
  updateLiveStats();
}
function updateLiveStats(){
  if(state.gameOver || !state.gameStarted){
    liveStats.classList.add('hidden');
    return;
  }
  liveStats.classList.remove('hidden');
  const age=(Date.now()-sessionStart)/1000;
  const lpm = age>0 ? (state.lines/(age/60)).toFixed(1) : '0.0';
  liveLpm.textContent = lpm;
  liveB2b.textContent = b2bActive ? '✓' : '—';
  liveCombo.textContent = comboCount>0 ? `x${comboCount}` : '—';
}

/* =========================
   GAMEPLAY
========================= */
function popNext(){
  while(queue.length<7) queue=queue.concat(newBag());
  const type=queue.shift(); 
  state.cur=spawn(type); 
  lockSince=null; 
  lockResets=0; 
  lastRotate=false; 
  drawNext();
  // Apply input buffer during ARE
  if(buffered.hold){ buffered.hold=false; holdSwap(); }
  if(buffered.rot){ buffered.rot=false; rotateCurCW(); }
  if(buffered.dir){ move(buffered.dir,0); buffered.dir=0; }
}
function holdSwap(){
  if(!canHold || !state.cur) return;
  const curType=state.cur.type;
  if(!state.hold){ 
    state.hold={type:curType}; 
    popNext(); 
  } else { 
    const swap=state.hold.type; 
    state.hold={type:curType}; 
    state.cur=spawn(swap); 
  }
  canHold=false; 
  drawHold(); 
  updateDisplay();
}
function touchingFloor(){ 
  return state.cur && !validAt(state.board,state.cur,state.cur.x,state.cur.y+1); 
}
function move(dx,dy){
  if(!state.cur) return false;
  const nx=state.cur.x+dx, ny=state.cur.y+dy;
  if(validAt(state.board,state.cur,nx,ny)){
    state.cur.x=nx; 
    state.cur.y=ny; 
    if(dx!==0) SND.move();
    if(dy>0 && !validAt(state.board,state.cur,nx,ny+1)) {
      if(lockSince===null) lockSince=performance.now();
    }
    if(dx!==0 && touchingFloor()){ 
      lockSince=performance.now(); 
      lockResets=Math.min(LOCK_RESET_MAX, lockResets+1); 
    }
    if(validAt(state.board,state.cur,state.cur.x,state.cur.y+1) && lockResets>0){ 
      lockResets=0; 
    }
    lastRotate=false; 
    return true;
  }
  if(dy!==0 && lockSince===null) lockSince=performance.now();
  return false;
}
function rotateCurCW(){
  if(!state.cur) return;
  const r=srsRotateCW(state.cur);
  if(r.ok){ 
    state.cur.shape=r.shape; 
    state.cur.x=r.x; 
    state.cur.y=r.y; 
    state.cur.o=r.o; 
    lastRotate=true; 
    lockSince=null; 
    SND.rotate(); 
    if(touchingFloor()){ 
      lockSince=performance.now(); 
      lockResets=Math.min(LOCK_RESET_MAX,lockResets+1); 
    } 
  } else { 
    roll.mis++; 
    lastRotate=false; 
  }
  updateDisplay();
}
function filledRows(){ 
  const rows=[]; 
  for(let y=0;y<BOARD_H;y++) {
    if(state.board[y].every(Boolean)) rows.push(y); 
  }
  return rows; 
}
function animateClear(rows, done){ 
  for(const y of rows) {
    for(let x=0;x<BOARD_W;x++) {
      cells[y*BOARD_W+x].classList.add('rowflash'); 
    }
  }
  setTimeout(done, LINE_CLEAR_DELAY_MS); 
}
function isTSpin(){
  if(!lastRotate || state.cur?.type!=='T') return false;
  const c={x:state.cur.x+1, y:state.cur.y+1};
  const corners=[[c.x-1,c.y-1],[c.x+1,c.y-1],[c.x-1,c.y+1],[c.x+1,c.y+1]];
  let occ=0; 
  for(const [x,y] of corners){ 
    if(x<0||x>=BOARD_W||y>=BOARD_H) occ++; 
    else if(y>=0 && state.board[y][x]) occ++; 
  }
  return occ>=3;
}
function isTSpinMini(linesCleared){
  if(!isTSpin()) return false;
  return linesCleared<=1;
}
function lockPiece(){
  const p=state.cur;
  for(let y=0;y<p.shape.length;y++) {
    for(let x=0;x<p.shape[y].length;x++) {
      if(p.shape[y][x]){ 
        const X=p.x+x,Y=p.y+y; 
        if(Y>=0) state.board[Y][X]=p.class; 
      }
    }
  }
  roll.locks++; 
  lockSince=null;
  const rows=filledRows(); 
  const tsp=isTSpin(); 
  const hadBlocks=state.board.some(r=>r.some(Boolean));
  
  if(rows.length>0){
    if(tsp) SND.tspin(); 
    else SND.line();
    
    animateClear(rows, ()=>{
      // Remove rows
      for(const y0 of rows){ 
        state.board.splice(y0,1); 
        state.board.unshift(Array(BOARD_W).fill(null)); 
      }
      
      // Scoring
      let gained = (SCORE_LINE[rows.length]||0) * Math.max(1,state.level);
      const mini = isTSpinMini(rows.length);
      if(tsp){ 
        gained += (mini?TSPIN_BONUS.mini:TSPIN_BONUS.full) * Math.max(1,state.level); 
        stats.tspins++; 
      }
      
      const isB2BType = tsp || rows.length===4;
      if(isB2BType && b2bActive){ 
        gained = Math.round(gained * B2B_MULT); 
        SND.b2b(); 
        showBanner('Back-to-Back!'); 
      }
      b2bActive = isB2BType ? true : false;
      
      comboCount = (comboCount>=0)? comboCount+1 : 0;
      if(comboCount>0){ 
        gained += COMBO_STEP*comboCount; 
        SND.combo(); 
        showBanner(`Combo x${comboCount}`); 
      }
      
      if(!state.board.some(r=>r.some(Boolean)) && hadBlocks){ 
        gained += PERFECT_CLEAR_BONUS; 
        stats.perfects++; 
        SND.pc(); 
        showBanner('Perfect Clear!'); 
      }
      
      if(state.symbolic){ 
        const misRate=roll.mis/Math.max(1,roll.locks); 
        const mult=Math.max(1,1+0.15*(1-Math.min(1,misRate))); 
        gained=Math.round(gained*mult); 
      }
      
      state.score+=gained; 
      state.lines+=rows.length; 
      state.level=Math.floor(state.lines/10)+1;
      areUntilTs = performance.now()+ARE_MS+LINE_CLEAR_DELAY_MS;
      popNext(); 
      canHold=true;
      
      if(!validAt(state.board,state.cur,state.cur.x,state.cur.y)) return gameOver();
      
      applyWorld(state.level); 
      playMusicForLevel(state.level);
      updateDisplay();
    });
  } else {
    comboCount=-1;
    areUntilTs = performance.now()+ARE_MS;
    popNext(); 
    canHold=true;
    
    if(!validAt(state.board,state.cur,state.cur.x,state.cur.y)) return gameOver();
    
    updateDisplay();
  }
}
function hardDrop(){
  let d=0; 
  while(move(0,1)) d++; 
  if(d>0){ 
    state.score += d*HARD_POINT; 
    roll.hard++; 
    SND.drop(); 
  } 
  lockPiece();
}
function gravityTick(dt, ts){
  state.acc+=dt; 
  const g=gravityInterval();
  while(state.acc>=g){
    state.acc-=g;
    if(!move(0,1)){
      const now=performance.now();
      if(lockSince===null) lockSince=now;
      const limit = lockResets>=LOCK_RESET_MAX;
      if(now - lockSince >= (limit?0:LOCK_DELAY)) lockPiece();
      break;
    }
  }
}
function showBanner(msg){ toast(msg); }

/* =========================
   ADAPTIVE + TELEMETRY
========================= */
let adaptClock=0;
function adaptTick(dt){
  if(!state.adaptive || state.paused || state.gameOver) return;
  adaptClock+=dt; 
  if(adaptClock<12000) return; 
  adaptClock=0;
  
  const age=(Date.now()-sessionStart)/1000;
  const lpm=state.lines/Math.max(1,age/60);
  const mis=roll.mis/Math.max(1,roll.locks);
  const latency=roll.meanLatency||120;
  const comfort=(lpm/1.5)+(1-Math.min(1,mis))+(120/Math.max(60,latency));
  
  if(comfort>=2.0){ 
    LOCK_DELAY=Math.max(200,LOCK_DELAY-40); 
    state.queueSize=Math.max(3,state.queueSize-1); 
  } else { 
    LOCK_DELAY=Math.min(800,LOCK_DELAY+40); 
    state.ghost=true; 
    state.queueSize=Math.min(5,Math.max(5,state.queueSize)); 
  }
  
  lockInput.value=LOCK_DELAY;
  drawNext();
}
function markInput(){
  const now=performance.now();
  const dt=now-roll.lastInputAt; 
  roll.lastInputAt=now; 
  roll.inputs++; 
  roll.meanLatency= roll.meanLatency===0? dt : 0.9*roll.meanLatency + 0.1*dt;
}
function pushRow(status){
  const dur=Math.round((Date.now()-sessionStart)/1000);
  const age=(Date.now()-sessionStart)/1000;
  const lpm=+(state.lines/Math.max(1,age/60)).toFixed(2);
  
  const row={ 
    ts:new Date().toISOString(), 
    student:studentId.value||"", 
    status, 
    score:state.score, 
    lines:state.lines, 
    level:state.level, 
    dur_s:dur, 
    lpm,
    inputs:roll.inputs, 
    latency_ms:Math.round(roll.meanLatency), 
    soft:roll.soft, 
    hard:roll.hard, 
    mis:roll.mis, 
    locks:roll.locks, 
    tspins:stats.tspins, 
    perfects:stats.perfects, 
    b2b:b2bActive?1:0, 
    combo:Math.max(0,comboCount) 
  };
  
  const arr=JSON.parse(localStorage.getItem(CLASS_KEY)||"[]"); 
  arr.push(row); 
  localStorage.setItem(CLASS_KEY, JSON.stringify(arr));
  renderTeacherStats(arr);
}
function exportCSV(){
  const arr=JSON.parse(localStorage.getItem(CLASS_KEY)||"[]"); 
  if(!arr.length){ alert("No data yet."); return; }
  
  const cols=["ts","student","status","score","lines","level","dur_s","lpm","inputs","latency_ms","soft","hard","mis","locks","tspins","perfects","b2b","combo"];
  const head=cols.join(",");
  const body=arr.map(r=>cols.map(k=>r?.[k]??"").join(",")).join("\n");
  const blob=new Blob([head+"\n"+body],{type:"text/csv"});
  const url=URL.createObjectURL(blob); 
  const a=document.createElement("a"); 
  a.href=url; 
  a.download="mr_scott_block_fun.csv"; 
  a.click(); 
  URL.revokeObjectURL(url);
}
function renderTeacherStats(arr){
  if(!arr.length){ 
    teacherStats.textContent="No sessions logged yet."; 
    return; 
  }
  
  const last=arr[arr.length-1];
  teacherStats.innerHTML = `
    Last: <b>${last.student||"?"}</b> — Score <b>${last.score}</b>, Lines <b>${last.lines}</b>, Level <b>${last.level}</b>, LPM <b>${last.lpm}</b><br/>
    Inputs <b>${last.inputs}</b>, Mean Latency <b>${last.latency_ms}ms</b>, Soft/Hard <b>${last.soft}/${last.hard}</b>, Mis-rotates <b>${last.mis}</b>
  `;
}

/* =========================
   LOOP
========================= */
function inARE(){ return areUntilTs > performance.now(); }
function loop(ts){
  const dt=ts-lastTs; 
  lastTs=ts;
  
  if(!state.paused && !state.gameOver){
    // ARE
    if(inARE()) { 
      loopRAF=requestAnimationFrame(loop); 
      return; 
    }

    // DAS/ARR
    if(input.left||input.right){
      const want = input.left? -1:+1;
      const dir = (input.left && input.right)? input.lastDir : want;
      input.das += dt;
      if(input.das>=DAS_MS){
        input.arr += dt;
        while(input.arr>=ARR_MS){ 
          if(!move(dir,0)) break; 
          input.arr-=ARR_MS; 
        }
      }
    } else { 
      input.das=0; 
      input.arr=0; 
    }

    // Gravity
    gravityTick(dt, ts);

    // Soft drop
    if(input.down){ 
      if(move(0,1)){ 
        state.score+=SOFT_POINT; 
        roll.soft++; 
      } 
    }

    adaptTick(dt);
    updateDisplay();
  }
  
  loopRAF=requestAnimationFrame(loop);
}

/* =========================
   LIFECYCLE
========================= */
function startGame(){
  LOCK_DELAY = +lockInput.value || LOCK_DELAY;
  const adaptive = optAdaptive.checked;
  const ghost = optGhost.checked;
  const symbolic = optSymbolic.checked;
  const qsize = +queueSizeSel.value || 5;
  rngSeed = optDaily.checked? dailySeed() : ((+seedInput.value)|| (Math.random()*1e9>>>0));

  state={ 
    board:[], 
    cur:null, 
    hold:null, 
    score:0, 
    lines:0, 
    level:1, 
    paused:false, 
    gameOver:false, 
    gameStarted:true,
    acc:0, 
    ghost, 
    adaptive, 
    symbolic, 
    queueSize:qsize 
  };
  
  // Reset stats
  sessionStart=Date.now(); 
  stats.tspins=0; 
  stats.perfects=0;
  roll.inputs=roll.soft=roll.hard=roll.mis=roll.locks=0; 
  roll.meanLatency=0; 
  roll.lastInputAt=performance.now();
  b2bActive=false; 
  comboCount=-1; 
  buffered={rot:false,hold:false,dir:0};

  makeBoard(); 
  queue=newBag(); 
  popNext(); 
  drawHold(); 
  drawNext(); 
  updateDisplay();
  
  // UI
  btnPause.disabled=false; 
  btnStart.disabled=true; 
  modalStart.classList.add('hidden'); 
  modalOver.classList.add('hidden');
  
  // Music/bg
  applyWorld(state.level); 
  playMusicForLevel(state.level);
  
  // Loop
  cancelAnimationFrame(loopRAF); 
  lastTs=performance.now(); 
  areUntilTs=0; 
  requestAnimationFrame(loop);
  pushRow('start');
}
function gameOver(){
  state.gameOver=true; 
  cancelAnimationFrame(loopRAF); 
  stopMusic(); 
  music.over.play().catch(e=>console.warn('Game over music blocked:', e)); 
  SND.over();
  
  ovScore.textContent=state.score; 
  ovLines.textContent=state.lines; 
  ovLevel.textContent=state.level;
  const age=(Date.now()-sessionStart)/1000; 
  ovLpm.textContent = (state.lines/Math.max(1,age/60)).toFixed(2);
  
  modalOver.classList.remove('hidden'); 
  btnStart.disabled=false; 
  btnPause.disabled=true;
  pushRow('gameover');
  liveStats.classList.add('hidden');
}
function pauseToggle(){
  if(state.gameOver || !state.cur) return;
  state.paused = !state.paused;
  
  if(state.paused){ 
    pushRow('pause'); 
    stopMusic(); 
  } else { 
    playMusicForLevel(state.level); 
    pushRow('resume'); 
  }
  
  btnPause.textContent = state.paused? 'Resume' : 'Pause';
}

/* =========================
   INPUT
========================= */
function kd(code){
  markInput();
  
  if(inARE()){
    // Buffer during entry
    if(code==='ArrowLeft'||code==='KeyA') { buffered.dir=-1; return; }
    if(code==='ArrowRight'||code==='KeyD'){ buffered.dir=+1; return; }
    if(code==='ArrowUp'||code==='Space'){ buffered.rot=true; return; }
    if(code==='KeyC'||code==='ShiftLeft'||code==='ShiftRight'){ buffered.hold=true; return; }
  }
  
  switch(code){
    case'ArrowLeft': case'KeyA': 
      if(!input.left){ 
        input.left=true; 
        input.lastDir=-1; 
        input.das=0; 
        input.arr=0; 
        move(-1,0);
      } 
      break;
    case'ArrowRight': case'KeyD': 
      if(!input.right){ 
        input.right=true; 
        input.lastDir=+1; 
        input.das=0; 
        input.arr=0; 
        move(+1,0);
      } 
      break;
    case'ArrowDown': case'KeyS': 
      input.down=true; 
      break;
    case'ArrowUp': case'Space': 
      rotateCurCW(); 
      break;
    case'Enter': 
      hardDrop(); 
      break;
    case'KeyC': case'ShiftLeft': case'ShiftRight': 
      holdSwap(); 
      break;
    case'KeyP': 
      pauseToggle(); 
      break;
  }
  updateDisplay();
}
function ku(code){
  switch(code){
    case'ArrowLeft': case'KeyA': 
      input.left=false; 
      input.lastDir=input.right?+1:0; 
      break;
    case'ArrowRight': case'KeyD': 
      input.right=false; 
      input.lastDir=input.left?-1:0; 
      break;
    case'ArrowDown': case'KeyS': 
      input.down=false; 
      break;
  }
}

// Event listeners
document.addEventListener('keydown', e=>{ 
  if(state.gameOver || !state.gameStarted || (modalStart.classList.contains('hidden') && modalOver.classList.contains('hidden') && modalTutorial.classList.contains('hidden'))) {
    if(state.gameStarted && !state.gameOver) kd(e.code); 
  } else {
    if(e.code==='Space'||e.code==='Enter'){ 
      if(!modalStart.classList.contains('hidden')) startGame(); 
      else if(!modalOver.classList.contains('hidden')) startGame(); 
    }
  }
});
document.addEventListener('keyup', e=>{ if(state.gameStarted && !state.gameOver) ku(e.code); });

// Button clicks
btnStart.addEventListener('click', startGame);
btnDoStart.addEventListener('click', startGame);
btnAgain.addEventListener('click', startGame);
btnPause.addEventListener('click', pauseToggle);
btnRotate.addEventListener('click', ()=>{ markInput(); rotateCurCW(); });
btnDrop.addEventListener('click', ()=>{ markInput(); hardDrop(); });
btnHold.addEventListener('click', ()=>{ markInput(); holdSwap(); });
btnExport.addEventListener('click', exportCSV);
btnResetData.addEventListener('click', ()=>{ 
  if(confirm('Clear all session data?')){ 
    localStorage.removeItem(CLASS_KEY); 
    renderTeacherStats([]); 
    toast('Data cleared'); 
  } 
});

// Options
optCB.addEventListener('change', ()=>{ 
  document.body.classList.toggle('colorblind', optCB.checked); 
});
optRM.addEventListener('change', ()=>{ 
  document.body.classList.toggle('reduced-motion', optRM.checked); 
});

/* =========================
   TUTORIAL
========================= */
const tutSlides = [
  `<b>Welcome to Mr. Scott's Block Fun!</b><br><br>This is an educational falling-blocks puzzle game with learning analytics for classroom data literacy. Use arrow keys or WASD to move, Up/Space to rotate, Enter to hard drop, and C/Shift to hold.`,
  
  `<b>Objective:</b><br><br>Clear horizontal lines by filling them completely with blocks. The game speeds up as you level up. Try to survive as long as possible and achieve the highest score!`,
  
  `<b>Controls:</b><br><br>
  • Left/Right (A/D): Move piece<br>
  • Down (S): Soft drop<br>
  • Up/Space: Rotate clockwise<br>
  • Enter: Hard drop<br>
  • C/Shift: Hold piece<br>
  • P: Pause`,
  
  `<b>Scoring:</b><br><br>
  • Single: 100 pts × level<br>
  • Double: 300 pts × level<br>
  • Triple: 500 pts × level<br>
  • Tetris (4 lines): 800 pts × level<br>
  • T-Spin: Bonus points<br>
  • Back-to-Back: 1.5× multiplier<br>
  • Combo: +50 pts per chain<br>
  • Perfect Clear: +1800 pts`,
  
  `<b>Options:</b><br><br>
  • <b>Ghost:</b> Shows where piece will land<br>
  • <b>Adaptive Mode:</b> Adjusts difficulty based on performance<br>
  • <b>Symbolic Boost:</b> Bonus scoring for accuracy<br>
  • <b>Daily Seed:</b> Same random sequence each day<br>
  • <b>Queue Size:</b> Number of next pieces shown (3-5)`,
  
  `<b>Teacher Analytics:</b><br><br>This game collects detailed metrics for data literacy education:<br><br>
  • Lines per minute (LPM)<br>
  • Input latency<br>
  • Piece placements<br>
  • T-Spins and Perfect Clears<br>
  • Combos and Back-to-Back chains<br><br>
  Export data as CSV for analysis!`
];

let tutIndex = 0;
function showTut(){
  tutorialContent.innerHTML = tutSlides[tutIndex];
  tutProgress.textContent = `${tutIndex+1} / ${tutSlides.length}`;
  tutPrev.disabled = tutIndex === 0;
  tutNext.textContent = tutIndex === tutSlides.length-1 ? 'Done' : 'Next →';
}
btnOpenTutorial.addEventListener('click', ()=>{ 
  tutIndex=0; 
  showTut(); 
  modalStart.classList.add('hidden'); 
  modalTutorial.classList.remove('hidden'); 
});
tutPrev.addEventListener('click', ()=>{ 
  if(tutIndex>0){ tutIndex--; showTut(); } 
});
tutNext.addEventListener('click', ()=>{ 
  if(tutIndex<tutSlides.length-1){ 
    tutIndex++; 
    showTut(); 
  } else { 
    modalTutorial.classList.add('hidden'); 
    modalStart.classList.remove('hidden'); 
  } 
});

/* =========================
   INIT
========================= */
renderTeacherStats(JSON.parse(localStorage.getItem(CLASS_KEY)||"[]"));
makeBoard();
updateDisplay();
</script>
</body>
</html>