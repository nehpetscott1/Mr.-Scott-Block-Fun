<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>MR. Scott's Block Fun</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="preconnect" href="https://fonts.googleapis.com"/>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet"/>
<style>
:root{
  --jade:#00A86B;
  --ink:#0af7a3;
  --cyan:#07e1ff;
  --panel:#083f2b;
  --panel2:#0b5a3b;
  --gridline: rgba(255,255,255,.12);
  --accent:#d9fff2;
  --text:#eafff8;
  --shadow: rgba(0,0,0,.35);
}
*{box-sizing:border-box;margin:0;padding:0}
html,body{height:100%}
body{
  font-family:'JetBrains Mono',monospace;
  background:linear-gradient(180deg, var(--jade), #028a5e 70%);
  color:var(--text);
  min-height:100vh;
  padding:1rem;
  overflow-x:hidden;
  position:relative;
}

body.fullscreen-mode{
  padding:0;
  overflow:hidden;
}

.mc-bg{position:fixed;inset:0;z-index:-2;pointer-events:none}
.mc-gradient{
  position:absolute;
  inset:-5%;
  background:radial-gradient(50% 40% at 20% 10%, rgba(255,255,255,.10), transparent 60%),
    radial-gradient(50% 40% at 80% 5%, rgba(255,255,255,.06), transparent 60%),
    radial-gradient(80% 70% at 50% 90%, rgba(0,0,0,.18), transparent 80%);
  filter:blur(18px) saturate(110%);
}
.mc-watermark{
  position:absolute;
  right:12px;
  bottom:10px;
  user-select:none;
  font-weight:800;
  letter-spacing:.25rem;
  font-size:.7rem;
  color:rgba(255,255,255,.25);
}

.container{max-width:1200px;margin:0 auto;position:relative}
body.fullscreen-mode .container{
  max-width:none;
  margin:0;
  padding:0;
}

.title{
  text-align:center;
  font-size:2.1rem;
  font-weight:800;
  letter-spacing:.15rem;
  margin-bottom:.5rem;
  color:#fff;
  text-shadow:0 2px 18px rgba(0,0,0,.25);
}
.subtitle{text-align:center;font-size:.95rem;opacity:.9;margin-bottom:1rem}

body.fullscreen-mode .title,
body.fullscreen-mode .subtitle{
  display:none;
}

.game-layout{display:grid;grid-template-columns:1fr minmax(280px,360px) 1fr;gap:1rem;align-items:start}
body.fullscreen-mode .game-layout{
  grid-template-columns:1fr auto;
  gap:0;
  height:100vh;
  padding:0;
  margin:0;
}

.side-panel{
  background:linear-gradient(180deg, var(--panel), var(--panel2));
  border:2px solid rgba(255,255,255,.2);
  border-radius:12px;
  padding:1rem;
  box-shadow:0 6px 22px var(--shadow), inset 0 0 22px rgba(0,0,0,.25);
}
body.fullscreen-mode .side-panel{
  border:none;
  border-radius:0;
  box-shadow:none;
  padding:.5rem;
  max-width:150px;
  overflow-y:auto;
}

body.fullscreen-mode .side-panel:first-of-type{
  display:none;
}

.panel-title{font-size:1rem;font-weight:800;text-align:center;margin:.3rem 0 .6rem}
.score-item{display:flex;justify-content:space-between;margin-bottom:.35rem;font-size:.95rem}
.score-value{color:#c8fff0;font-weight:800}

.game-board{
  border:4px solid rgba(255,255,255,.35);
  border-radius:12px;
  background:radial-gradient(120% 120% at 50% 10%, rgba(0,0,0,.35), rgba(0,0,0,.45));
  box-shadow:0 10px 30px var(--shadow), inset 0 0 28px rgba(0,0,0,.35);
  display:flex;
  justify-content:center;
  align-items:center;
  padding:6px;
}
body.fullscreen-mode .game-board{
  border:none;
  border-radius:0;
  box-shadow:none;
  padding:0;
  flex:1;
  background:#000;
}

#gameCanvas{
  display:block;
  image-rendering:pixelated;
  max-width:100%;
  height:auto;
  cursor:pointer;
  outline:none;
}
body.fullscreen-mode #gameCanvas{
  width:100%;
  height:100%;
}

.mini-grid{
  width:96px;
  height:96px;
  border:2px solid rgba(255,255,255,.2);
  border-radius:8px;
  background:#00180f;
  margin:.35rem auto;
  display:grid;
  grid-template-columns:repeat(4,1fr);
  grid-template-rows:repeat(4,1fr);
  gap:2px;
  padding:4px;
}
body.fullscreen-mode .mini-grid{
  width:70px;
  height:70px;
  margin:.2rem auto;
}

.preview-cell{background:#00180f;border-radius:3px}
.mini-list{display:grid;grid-template-columns:1fr;gap:.35rem;justify-items:center}

.controls{display:grid;grid-template-columns:1fr 1fr;gap:.5rem}
body.fullscreen-mode .controls{
  grid-template-columns:1fr;
  gap:.3rem;
}

.btn{
  background:rgba(0,40,26,.9);
  border:2px solid rgba(255,255,255,.3);
  color:#e6fff6;
  padding:.6rem .8rem;
  border-radius:10px;
  font-weight:700;
  cursor:pointer;
  transition:.15s;
  text-transform:uppercase;
  touch-action:manipulation;
  font-size:.85rem;
}
body.fullscreen-mode .btn{
  padding:.4rem .5rem;
  font-size:.7rem;
}

.btn:hover:not(:disabled){
  background:rgba(0,55,35,.95);
  border-color:#b6fff1;
  box-shadow:0 0 12px rgba(255,255,255,.18);
}
.btn:disabled{opacity:.55;cursor:not-allowed}
.btn-primary{background:linear-gradient(180deg,#0a5,#094);color:#fff;grid-column:span 2}
body.fullscreen-mode .btn-primary{grid-column:span 1}
.btn-wide{grid-column:span 2}
body.fullscreen-mode .btn-wide{grid-column:span 1}
.hidden{display:none!important}

.opt{
  display:grid;
  grid-template-columns:auto 1fr;
  gap:.45rem .6rem;
  align-items:center;
  font-size:.85rem;
  margin-top:.4rem;
}
body.fullscreen-mode .opt{
  font-size:.7rem;
  margin-top:.2rem;
}

.opt input[type="number"],
.opt select,
.opt input[type="text"]{
  background:#002217;
  color:#d7fff3;
  border:1px solid rgba(255,255,255,.2);
  border-radius:8px;
  padding:.4rem .5rem;
  width:100%;
}
body.fullscreen-mode .opt input,
body.fullscreen-mode .opt select{
  padding:.3rem .3rem;
  font-size:.7rem;
}

.opt input[type="range"]{width:100%}
.opt .hint{font-size:.75rem;opacity:.8;grid-column:span 2}

.modal{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.88);
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:1000;
  padding:1rem;
}
.modal-content{
  background:#062b1d;
  border:4px solid rgba(255,255,255,.35);
  border-radius:14px;
  padding:1.2rem;
  text-align:center;
  max-width:760px;
  width:100%;
  box-shadow:0 0 30px rgba(0,0,0,.45);
}
.modal-title{font-size:2rem;font-weight:900;margin-bottom:.4rem;color:#fff}
.modal-text{margin-bottom:.8rem;color:#c9fff0}
.modal-stats{margin:.6rem 0;display:grid;grid-template-columns:repeat(3,1fr);gap:.6rem}
.stat-item{background:#001a11;border:1px solid rgba(255,255,255,.2);border-radius:10px;padding:.45rem}
.stat-value{font-size:1.1rem;font-weight:900;color:#b6fff1}
.stat-label{font-size:.75rem;color:#9fffd7}

.kbd-grid{display:grid;grid-template-columns:1fr 1fr;gap:.5rem .6rem;margin-top:.4rem;text-align:left}
.kbd-grid label{font-size:.85rem}
.kbd-grid input{
  background:#002217;
  color:#d7fff3;
  border:1px solid rgba(255,255,255,.2);
  border-radius:8px;
  padding:.4rem .5rem;
}

.tut-body{text-align:left;font-size:.95rem;color:#d7fff3}
.tut-nav{display:flex;justify-content:center;gap:.6rem;margin-top:.6rem}

.color-I{background:#00f0ff!important}
.color-O{background:#ffd900!important}
.color-T{background:#b38bff!important}
.color-S{background:#21ff88!important}
.color-Z{background:#ff5c5c!important}
.color-J{background:#4a74ff!important}
.color-L{background:#ff9a2b!important}

#orientHint{
  position:fixed;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  background:rgba(0,0,0,.88);
  color:#eafff8;
  z-index:2000;
  text-align:center;
  padding:1rem;
}
#orientHint p{max-width:520px}

@media (max-width:1024px){
  .game-layout{grid-template-columns:1fr;gap:1rem}
  .title{font-size:1.9rem}
}
</style>
</head>
<body>
  <div class="mc-bg" aria-hidden="true">
    <div class="mc-gradient"></div>
    <div class="mc-watermark">JADE</div>
  </div>
  <div class="container" role="application" aria-label="Tetris game">
    <h1 class="title">MR. Scott's Block Fun</h1>

    <div class="game-layout">
      <aside class="side-panel" aria-label="Score and queue">
        <div class="panel-title">PLAYER</div>
        <div class="opt">
          <label for="playerName">Name</label>
          <input id="playerName" type="text" placeholder="e.g., Jordan A." maxlength="40"/>
        </div>

        <div class="panel-title" style="margin-top:.6rem;">SCORE</div>
        <div class="score-item"><span>Score</span><span class="score-value" id="score">0</span></div>
        <div class="score-item"><span>Lines</span><span class="score-value" id="lines">0</span></div>
        <div class="score-item"><span>Level</span><span class="score-value" id="level">1</span></div>
        <div class="score-item"><span>T-Spins</span><span class="score-value" id="tspinDisplay">0</span></div>

        <div class="panel-title" style="margin-top:.6rem;">HOLD</div>
        <div class="mini-grid" id="holdBox" aria-label="Hold preview"></div>

        <div class="panel-title" style="margin-top:.6rem;">NEXT</div>
        <div class="mini-list" id="nextList" aria-label="Next pieces">
          <div class="mini-grid"></div>
          <div class="mini-grid"></div>
          <div class="mini-grid"></div>
          <div class="mini-grid"></div>
          <div class="mini-grid"></div>
        </div>
      </aside>

      <main class="game-board" id="gameBoard">
        <canvas id="gameCanvas" aria-label="Game board" role="img" tabindex="0"></canvas>
      </main>

      <aside class="side-panel" aria-label="Controls and options">
        <div class="panel-title">CONTROLS</div>
        <div class="controls" role="group" aria-label="Game controls">
          <button class="btn btn-primary" id="startBtn">START</button>
          <button class="btn hidden" id="pauseBtn">PAUSE</button>
          <button class="btn" id="rotateBtn">ROTATE</button>
          <button class="btn" id="dropBtn">DROP</button>
          <button class="btn" id="holdBtn">HOLD</button>
          <button class="btn" id="keysBtn">KEYS</button>
          <button class="btn" id="tutorialBtn">HELP</button>
          <button class="btn" id="fullscreenBtn">FULLSCREEN</button>
          <button class="btn hidden" id="exitFullscreenBtn">EXIT FS</button>
          <button class="btn" id="exportBtn">EXPORT</button>
          <button class="btn" id="exportMineBtn">MY DATA</button>
        </div>

        <div class="panel-title" style="margin-top:.6rem;">MODE</div>
        <div class="opt" role="group" aria-label="Classroom options">
          <label>Game Mode</label>
          <select id="clsMode">
            <option value="free">Free Play</option>
            <option value="timed120">Timed (2m)</option>
            <option value="drill_tspin">T-Spin Drill</option>
            <option value="drill_pc">Perfect Clear</option>
          </select>

          <label>Seed</label>
          <select id="clsSeed">
            <option value="daily">Daily</option>
            <option value="123456">#123456</option>
            <option value="8675309">#8675309</option>
            <option value="424242">#424242</option>
            <option value="987654321">#987654321</option>
          </select>

          <label>Zoom</label>
          <select id="clsZoom">
            <option value="1">Normal</option>
            <option value="1.25">Large</option>
            <option value="1.5">XL</option>
          </select>

          <label>Speed</label>
          <select id="clsSlow">
            <option value="1">1x</option>
            <option value="1.25">1.25x</option>
            <option value="1.5">1.5x</option>
            <option value="2">2x</option>
          </select>
        </div>

        <div class="panel-title" style="margin-top:.6rem;">OPTIONS</div>
        <div class="opt">
          <label><input type="checkbox" id="optAdaptive" checked/> Adaptive</label><span></span>
          <label>Lock</label><input type="range" id="optLock" min="200" max="800" value="500"/>
          <label><input type="checkbox" id="optGhost" checked/> Ghost</label><span></span>
          <label>Opacity</label><input type="range" id="optGhostAlpha" min="0.1" max="0.6" step="0.05" value="0.25"/>
          <label><input type="checkbox" id="optSymbolic"/> Symbolic</label><span></span>
        </div>
      </aside>
    </div>

    <!-- Modals (keep all the existing modals from before) -->
    <div class="modal hidden" id="startModal" aria-modal="true" role="dialog">
      <div class="modal-content">
        <div class="modal-title">MR. Scott's Block Fun</div>
        <div class="modal-text">Jade green Tetris for the classroom</div>
        <div id="bestWrap" style="margin:.4rem 0 .2rem;font-size:.9rem;opacity:.85;"></div>
        <div style="display:flex;gap:.6rem;flex-wrap:wrap;justify-content:center;">
          <button class="btn" id="startModalTutBtn" style="min-width:160px;">TUTORIAL</button>
          <button class="btn btn-primary" id="startModalStartBtn" style="min-width:160px;">START GAME</button>
        </div>
        <div style="margin-top:.6rem;font-size:.8rem;opacity:.75;">Press SPACE or ENTER to start</div>
      </div>
    </div>

    <div class="modal hidden" id="gameOverModal" aria-modal="true" role="dialog">
      <div class="modal-content">
        <div class="modal-title">GAME OVER</div>
        <div class="modal-stats">
          <div class="stat-item"><div class="stat-value" id="finalScore">0</div><div class="stat-label">SCORE</div></div>
          <div class="stat-item"><div class="stat-value" id="finalLines">0</div><div class="stat-label">LINES</div></div>
          <div class="stat-item"><div class="stat-value" id="finalLevel">1</div><div class="stat-label">LEVEL</div></div>
          <div class="stat-item"><div class="stat-value" id="finalLPM">0</div><div class="stat-label">LPM</div></div>
          <div class="stat-item"><div class="stat-value" id="finalTSpins">0</div><div class="stat-label">T-SPINS</div></div>
          <div class="stat-item"><div class="stat-value" id="finalPCs">0</div><div class="stat-label">PERFECT CLEARS</div></div>
        </div>
        <div style="display:flex;gap:.6rem;flex-wrap:wrap;justify-content:center;">
          <button class="btn" id="gameOverRestartBtn" style="min-width:160px;">PLAY AGAIN</button>
          <button class="btn btn-primary" id="gameOverRetrySeedBtn" style="min-width:180px;">RETRY SEED</button>
        </div>
        <div style="margin-top:.6rem;font-size:.8rem;opacity:.75;">Press SPACE or ENTER to start</div>
      </div>
    </div>

    <div class="modal hidden" id="pauseModal" aria-modal="true" role="dialog">
      <div class="modal-content">
        <div class="modal-title">PAUSED</div>
        <div class="modal-text">Press P or click PAUSE to continue.</div>
      </div>
    </div>

    <div class="modal hidden" id="keysModal" aria-modal="true" role="dialog">
      <div class="modal-content">
        <div class="modal-title">KEY BINDS</div>
        <div class="kbd-grid">
          <label>Left</label><input id="kbLeft" placeholder="ArrowLeft"/>
          <label>Right</label><input id="kbRight" placeholder="ArrowRight"/>
          <label>Soft Drop</label><input id="kbDown" placeholder="ArrowDown"/>
          <label>Rotate</label><input id="kbRotate" placeholder="ArrowUp / Space"/>
          <label>Hard Drop</label><input id="kbHard" placeholder="Enter"/>
          <label>Hold</label><input id="kbHold" placeholder="Shift / C"/>
          <label>Pause</label><input id="kbPause" placeholder="P"/>
        </div>
        <div style="display:flex;gap:.6rem;justify-content:center;margin-top:.6rem;">
          <button class="btn" id="kbCancel">Cancel</button>
          <button class="btn btn-primary" id="kbSave">Save</button>
        </div>
      </div>
    </div>

    <div class="modal hidden" id="tutorialModal" aria-modal="true" role="dialog">
      <div class="modal-content" style="max-width:720px;">
        <div class="modal-title">TUTORIAL</div>
        <div id="tutBody" class="tut-body"></div>
        <div class="tut-nav">
          <button class="btn" id="tutPrev">Back</button>
          <button class="btn" id="tutExit">Exit</button>
          <button class="btn btn-primary" id="tutNext">Next</button>
        </div>
      </div>
    </div>
  </div>
  <div id="orientHint"><p>For a better classroom experience, rotate your device to <b>landscape</b> or use a wider window. <b>Click inside the game board to enable keyboard controls.</b></p></div>

<script src="mc_tetris_part2.js"></script>
</body>
</html>

<script>
"use strict";

/* ---------- UTILITIES ---------- */
function mustGet(id){
  const el=document.getElementById(id);
  if(!el) throw new Error('Missing #' + id);
  return el;
}

const store = {
  get:(k,f='')=>{ try{ return localStorage.getItem(k) ?? f }catch{ return f } },
  set:(k,v)=>{ try{ localStorage.setItem(k,v); return true } catch(e){ console.error('Storage error:',e); return false; } }
};

function safeReadJSON(key, fallback){
  try{
    const raw=store.get(key, JSON.stringify(fallback));
    const parsed=JSON.parse(raw);
    return (Array.isArray(parsed)||typeof parsed==='object')?parsed:fallback;
  }
  catch{ return fallback; }
}

/* ---------- CONSTANTS ---------- */
const BOARD_WIDTH=10, BOARD_HEIGHT=20;
let CSS_CELL=32;
const INITIAL_SPEED=500;
let LOCK_DELAY=500;
const SOFT_POINT=1, HARD_POINT=2;
const LINE_SCORE=[0,100,300,500,800];
const TSPIN_BONUS=400, PERFECT_CLEAR_BONUS=1800;
const CLASS_KEY='mc_tetris_classlog';
const BEST_KEY='mc_tetris_best';
const NAME_KEY='mc_tetris_name';
const LOG_CAP=500;
const VALID_MODES=['free','timed120','drill_tspin','drill_pc'];

/* ---------- CANVAS SETUP ---------- */
const canvas=mustGet('gameCanvas');
const ctx=canvas.getContext('2d',{alpha:false});
let gridLayer=null, gridLayerCtx=null;

function buildGridLayer(){
  gridLayer=document.createElement('canvas');
  gridLayer.width=BOARD_WIDTH*CSS_CELL;
  gridLayer.height=BOARD_HEIGHT*CSS_CELL;
  gridLayerCtx=gridLayer.getContext('2d',{alpha:false});
  gridLayerCtx.fillStyle='#00180f';
  gridLayerCtx.fillRect(0,0,gridLayer.width,gridLayer.height);
  gridLayerCtx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--gridline') || 'rgba(255,255,255,.12)';
  gridLayerCtx.lineWidth=1;
  for(let x=0;x<=BOARD_WIDTH;x++){
    gridLayerCtx.beginPath();
    gridLayerCtx.moveTo(x*CSS_CELL,0);
    gridLayerCtx.lineTo(x*CSS_CELL,BOARD_HEIGHT*CSS_CELL);
    gridLayerCtx.stroke();
  }
  for(let y=0;y<=BOARD_HEIGHT;y++){
    gridLayerCtx.beginPath();
    gridLayerCtx.moveTo(0,y*CSS_CELL);
    gridLayerCtx.lineTo(BOARD_WIDTH*CSS_CELL,y*CSS_CELL);
    gridLayerCtx.stroke();
  }
}

function resizeCanvas(){
  const dpr=Math.max(1,Math.floor(window.devicePixelRatio||1));
  const cssW=Math.floor(BOARD_WIDTH*CSS_CELL);
  const cssH=Math.floor(BOARD_HEIGHT*CSS_CELL);
  canvas.style.width=cssW+'px';
  canvas.style.height=cssH+'px';
  canvas.width=cssW*dpr;
  canvas.height=cssH*dpr;
  ctx.setTransform(dpr,0,0,dpr,0,0);
  buildGridLayer();
}

/* ---------- DOM REFS ---------- */
const orientHint=mustGet('orientHint');
function updateOrientHint(){
  const w=innerWidth, h=innerHeight;
  orientHint.style.display=(w<h&&w<700)?'flex':'none';
}

const startModal=mustGet('startModal');
const gameOverModal=mustGet('gameOverModal');
const pauseModal=mustGet('pauseModal');
const keysModal=mustGet('keysModal');
const tutorialModal=mustGet('tutorialModal');

const startBtn=mustGet('startBtn');
const startModalStartBtn=mustGet('startModalStartBtn');
const startModalTutBtn=mustGet('startModalTutBtn');
const gameOverRestartBtn=mustGet('gameOverRestartBtn');
const gameOverRetrySeedBtn=mustGet('gameOverRetrySeedBtn');

const pauseBtn=mustGet('pauseBtn');
const rotateBtn=mustGet('rotateBtn');
const dropBtn=mustGet('dropBtn');
const holdBtn=mustGet('holdBtn');
const keysBtn=mustGet('keysBtn');
const tutorialBtn=mustGet('tutorialBtn');
const exportBtn=mustGet('exportBtn');
const exportMineBtn=mustGet('exportMineBtn');
const fullscreenBtn=mustGet('fullscreenBtn');
const exitFullscreenBtn=mustGet('exitFullscreenBtn');

const scoreEl=mustGet('score');
const linesEl=mustGet('lines');
const levelEl=mustGet('level');
const tspinDisplayEl=mustGet('tspinDisplay');
const holdBox=mustGet('holdBox');
const nextList=mustGet('nextList');
const playerName=mustGet('playerName');

const optAdaptive=mustGet('optAdaptive');
const optLock=mustGet('optLock');
const optGhost=mustGet('optGhost');
const optGhostAlpha=mustGet('optGhostAlpha');
const optSymbolic=mustGet('optSymbolic');

const clsMode=mustGet('clsMode');
const clsSeed=mustGet('clsSeed');
const clsZoom=mustGet('clsZoom');
const clsSlow=mustGet('clsSlow');

const bestWrap=mustGet('bestWrap');

const btns={
  kb:{
    modal:keysModal,
    left:mustGet('kbLeft'),
    right:mustGet('kbRight'),
    down:mustGet('kbDown'),
    rotate:mustGet('kbRotate'),
    hard:mustGet('kbHard'),
    hold:mustGet('kbHold'),
    pause:mustGet('kbPause'),
    save:mustGet('kbSave'),
    cancel:mustGet('kbCancel')
  },
  tut:{
    body:mustGet('tutBody'),
    prev:mustGet('tutPrev'),
    next:mustGet('tutNext'),
    exit:mustGet('tutExit')
  }
};

/* ---------- PIECES ---------- */
const COLOR_MAP={
  'color-I':'#00f0ff',
  'color-O':'#ffd900',
  'color-T':'#b38bff',
  'color-S':'#21ff88',
  'color-Z':'#ff5c5c',
  'color-J':'#4a74ff',
  'color-L':'#ff9a2b'
};

const TETROMINOES={
  I:{shape:[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],class:'color-I',id:1},
  O:{shape:[[1,1],[1,1]],class:'color-O',id:3},
  T:{shape:[[0,1,0],[1,1,1],[0,0,0]],class:'color-T',id:2},
  S:{shape:[[0,1,1],[1,1,0],[0,0,0]],class:'color-S',id:4},
  Z:{shape:[[1,1,0],[0,1,1],[0,0,0]],class:'color-Z',id:5},
  J:{shape:[[1,0,0],[1,1,1],[0,0,0]],class:'color-J',id:6},
  L:{shape:[[0,0,1],[1,1,1],[0,0,0]],class:'color-L',id:7}
};
const TYPES=Object.keys(TETROMINOES);

/* SRS KICK DATA */
const SRS_JLSTZ={
  '0>1':[[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
  '1>0':[[0,0],[1,0],[1,1],[0,-2],[1,-2]],
  '1>2':[[0,0],[1,0],[1,1],[0,-2],[1,-2]],
  '2>1':[[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
  '2>3':[[0,0],[1,0],[1,-1],[0,2],[1,2]],
  '3>2':[[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
  '3>0':[[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
  '0>3':[[0,0],[1,0],[1,-1],[0,2],[1,2]]
};

const SRS_I={
  '0>1':[[0,0],[-2,0],[1,0],[-2,1],[1,-2]],
  '1>0':[[0,0],[2,0],[-1,0],[2,-1],[-1,2]],
  '1>2':[[0,0],[-1,0],[2,0],[-1,-2],[2,1]],
  '2>1':[[0,0],[1,0],[-2,0],[1,2],[-2,-1]],
  '2>3':[[0,0],[2,0],[-1,0],[2,-1],[-1,2]],
  '3>2':[[0,0],[-2,0],[1,0],[-2,1],[1,-2]],
  '3>0':[[0,0],[1,0],[-2,0],[1,2],[-2,-1]],
  '0>3':[[0,0],[-1,0],[2,0],[-1,-2],[2,1]]
};

/* ---------- RNG ---------- */
let rngSeed=(Math.random()*1e9)>>>0;

function dailySeed(){
  const d=new Date();
  return (d.getFullYear()*10000+(d.getMonth()+1)*100+d.getDate())>>>0;
}

function xs32(){
  rngSeed^=rngSeed<<13;
  rngSeed^=rngSeed>>>17;
  rngSeed^=rngSeed<<5;
  return (rngSeed>>>0)/0xffffffff;
}

function newBag(){
  const arr=[1,2,3,4,5,6,7];
  for(let i=arr.length-1;i>0;i--){
    const j=Math.floor(xs32()*(i+1));
    [arr[i],arr[j]]=[arr[j],arr[i]];
  }
  return arr.map(id=>TYPES.find(k=>TETROMINOES[k].id===id));
}

/* ---------- STATE ---------- */
let state={};
let queue=[], canHold=true, lockSince=null, loopHandle=0;
let lastActionWasRotate=false, animClearing=false;
let ghostAlpha=0.25, sessionStart=Date.now();
const stats={tspins:0,perfects:0};
const roll={inputs:0,soft:0,hard:0,mis:0,locks:0,rotFail:0,lastInputAt:performance.now(),meanLatency:0};
let lastTs=performance.now(), lastStartedSeed=null, slowMo=1;
let isFullscreen=false;

/* ---------- HELPERS ---------- */
function makeBoard(){
  state.board=Array.from({length:BOARD_HEIGHT},()=>Array.from({length:BOARD_WIDTH},()=>null));
}

function spawnPiece(t){
  const d=TETROMINOES[t];
  return {
    type:t,
    class:d.class,
    o:0,
    shape:d.shape.map(r=>r.slice()),
    x:Math.floor(BOARD_WIDTH/2)-Math.floor(d.shape[0].length/2),
    y:-1
  };
}

function currentCells(p){
  const a=[];
  for(let py=0;py<p.shape.length;py++){
    for(let px=0;px<p.shape[py].length;px++){
      if(p.shape[py][px]) a.push({x:p.x+px,y:p.y+py});
    }
  }
  return a;
}

function validAt(board,p,X,Y,shapeOverride=null){
  const shp=shapeOverride||p.shape;
  for(let py=0;py<shp.length;py++){
    for(let px=0;px<shp[py].length;px++){
      if(shp[py][px]){
        const x=X+px, y=Y+py;
        if(x<0||x>=BOARD_WIDTH||y>=BOARD_HEIGHT) return false;
        if(y>=0 && board[y][x]) return false;
      }
    }
  }
  return true;
}

function rotCW(shape){
  const r=shape.length, c=shape[0].length;
  const out=Array.from({length:c},()=>Array(r).fill(0));
  for(let i=0;i<r;i++){
    for(let j=0;j<c;j++){
      out[j][r-1-i]=shape[i][j];
    }
  }
  return out;
}

function srsRotateCW(p){
  const from=p.o, to=(p.o+1)&3, cand=rotCW(p.shape);
  if(p.type==='O'){
    if(validAt(state.board,p,p.x,p.y,cand)) return {ok:true,x:p.x,y:p.y,shape:cand,o:to};
    return {ok:false};
  }
  const table=(p.type==='I')?SRS_I:SRS_JLSTZ;
  const kicks=table[`${from}>${to}`];
  for(const [dx,dy] of kicks){
    const nx=p.x+dx, ny=p.y+dy;
    if(validAt(state.board,p,nx,ny,cand)) return {ok:true,x:nx,y:ny,shape:cand,o:to};
  }
  return {ok:false};
}

function ghostY(board,p){
  let y=p.y;
  while(validAt(board,p,p.x,y+1)) y++;
  return y;
}

/* ---------- UI MINI PREVIEWS ---------- */
function miniGrid(el,shape,cls){
  el.innerHTML='';
  for(let y=0;y<4;y++){
    for(let x=0;x<4;x++){
      const c=document.createElement('div');
      c.className='preview-cell';
      if(shape?.[y]?.[x]) c.classList.add(cls);
      el.appendChild(c);
    }
  }
}

function drawHold(){
  const h=state.hold?TETROMINOES[state.hold.type]:null;
  const sh=h?h.shape:[[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]];
  miniGrid(holdBox,sh,h?h.class:'');
}

function drawNext(){
  const minis=[...nextList.querySelectorAll('.mini-grid')];
  minis.forEach((m,i)=>{ m.style.display=(i<(state.queueSize||5))?'':'none'; });
  for(let i=0;i<minis.length;i++){
    const t=queue[i];
    const d=t?TETROMINOES[t]:null;
    const blank=[[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]];
    miniGrid(minis[i], d?d.shape:blank, d?d.class:'');
  }
}

/* ---------- RENDERING ---------- */
function drawCell(x,y,cls,alpha=1){
  const color=COLOR_MAP[cls]||'#fff';
  const px=x*CSS_CELL, py=y*CSS_CELL;
  ctx.globalAlpha=alpha;
  ctx.fillStyle=color;
  ctx.fillRect(px+1,py+1,CSS_CELL-2,CSS_CELL-2);
  ctx.fillStyle='rgba(255,255,255,0.22)';
  ctx.fillRect(px+1,py+1,CSS_CELL-2,Math.floor(CSS_CELL/3));
  ctx.fillStyle='rgba(0,0,0,0.22)';
  ctx.fillRect(px+1,py+CSS_CELL-Math.floor(CSS_CELL/3),CSS_CELL-2,Math.floor(CSS_CELL/3));
  ctx.globalAlpha=1;
}

function drawBoard(){
  ctx.drawImage(gridLayer,0,0);
  for(let y=0;y<BOARD_HEIGHT;y++){
    for(let x=0;x<BOARD_WIDTH;x++){
      if(state.board[y][x]) drawCell(x,y,state.board[y][x]);
    }
  }
  if(state.ghost && state.cur && !animClearing){
    const gy=ghostY(state.board,state.cur);
    for(const {x,y} of currentCells({...state.cur,y:gy})){
      if(y>=0) drawCell(x,y,state.cur.class,ghostAlpha);
    }
  }
  if(state.cur){
    for(const {x,y} of currentCells(state.cur)){
      if(y>=0) drawCell(x,y,state.cur.class);
    }
  }
  if(lockSince!==null && state.cur){
    const pulse=Math.sin((performance.now()-lockSince)/100)*0.2+0.8;
    ctx.globalAlpha=pulse;
    for(const {x,y} of currentCells(state.cur)){
      if(y>=0){
        ctx.fillStyle='rgba(255,255,255,0.15)';
        ctx.fillRect(x*CSS_CELL,y*CSS_CELL,CSS_CELL,CSS_CELL);
      }
    }
    ctx.globalAlpha=1;
  }
}

function updateDisplay(){
  drawBoard();
  scoreEl.textContent=String(state.score);
  linesEl.textContent=String(state.lines);
  levelEl.textContent=String(state.level);
  tspinDisplayEl.textContent=String(stats.tspins);
}

/* ---------- QUEUE & MOVES ---------- */
function popNext(){
  while(queue.length<7) queue=queue.concat(newBag());
  const type=queue.shift();
  state.cur=spawnPiece(type);
  lastActionWasRotate=false;
  lockSince=null;
  drawNext();
}

function ensureSpawnValid(){
  if(!validAt(state.board,state.cur,state.cur.x,state.cur.y)){
    gameOver();
    return false;
  }
  return true;
}

function holdSwap(){
  if(!canHold||!state.cur) return;
  const curType=state.cur.type;
  if(!state.hold){
    state.hold={type:curType};
    popNext();
  } else {
    const swap=state.hold.type;
    state.hold={type:curType};
    state.cur=spawnPiece(swap);
  }
  canHold=false;
  lastActionWasRotate=false;
  lockSince=null;
  drawHold();
  if(!ensureSpawnValid()) return;
}

function move(dx,dy){
  if(!state.cur) return false;
  const nx=state.cur.x+dx, ny=state.cur.y+dy;
  if(validAt(state.board,state.cur,nx,ny)){
    state.cur.x=nx;
    state.cur.y=ny;
    if(dy>0) lastActionWasRotate=false;
    return true;
  }
  if(dx!==0) roll.mis++;
  return false;
}

function filledRows(){
  const rows=[];
  for(let y=0;y<BOARD_HEIGHT;y++){
    let filled=true;
    for(let x=0;x<BOARD_WIDTH;x++){
      if(!state.board[y][x]){
        filled=false;
        break;
      }
    }
    if(filled) rows.push(y);
  }
  return rows;
}

/* ---------- T-SPIN DETECTION (IMPROVED) ---------- */
function isTSpin(){
  if(!lastActionWasRotate || state.cur?.type!=='T') return false;
  const c={x:state.cur.x+1,y:state.cur.y+1};
  const corners=[{x:c.x-1,y:c.y-1},{x:c.x+1,y:c.y-1},{x:c.x-1,y:c.y+1},{x:c.x+1,y:c.y+1}];
  const filled=corners.filter(({x,y})=> x<0||x>=BOARD_WIDTH||y<0||y>=BOARD_HEIGHT||state.board[y]?.[x]).length;
  return filled>=3;
}

/* ---------- CLEAR & SCORING (FIXED 4-LINE BUG) ---------- */
function animateClearAndApply(rows, onDone){
  if(rows.length===0){
    onDone && onDone();
    return;
  }

  animClearing=true;
  let flash=0;
  const max=6;
  const iv=setInterval(()=>{
    flash++;
    for(const y of rows){
      for(let x=0;x<BOARD_WIDTH;x++){
        ctx.fillStyle=(flash%2===0)?'#9dffb6':'#ffffff';
        ctx.fillRect(x*CSS_CELL+1, y*CSS_CELL+1, CSS_CELL-2, CSS_CELL-2);
      }
    }
    if(flash>=max){
      clearInterval(iv);
      const sorted=rows.slice().sort((a,b)=>b-a);
      for(const y of sorted){
        state.board.splice(y,1);
        state.board.unshift(Array(BOARD_WIDTH).fill(null));
      }
      animClearing=false;
      onDone && onDone();
    }
  }, 70);
}

function lockPiece(){
  const p=state.cur;
  for(let py=0;py<p.shape.length;py++){
    for(let px=0;px<p.shape[py].length;px++){
      if(p.shape[py][px]){
        const x=p.x+px, y=p.y+py;
        if(y>=0) state.board[y][x]=p.class;
      }
    }
  }
  roll.locks++;
  lockSince=null;

  const rows=filledRows();
  const hadBlocks=state.board.some(r=>r.some(Boolean));

  if(rows.length>0){
    const tspin=isTSpin();
    
    animateClearAndApply(rows, ()=>{
      let gained=LINE_SCORE[rows.length]*Math.max(1,state.level);
      if(tspin){ gained+=TSPIN_BONUS; stats.tspins++; console.log('[Game] T-SPIN detected! Total:', stats.tspins); }
      if(!state.board.some(r=>r.some(Boolean))&&hadBlocks){ gained+=PERFECT_CLEAR_BONUS; stats.perfects++; }
      if(optSymbolic.checked){
        const misRate=roll.mis/Math.max(1,roll.locks);
        const mult=Math.max(1,1+0.15*(1-Math.min(1,misRate)));
        gained=Math.round(gained*mult);
      }
      state.score+=gained;
      state.lines+=rows.length;
      state.level=Math.floor(state.lines/10)+1;

      if(clsMode.value==='drill_tspin' && tspin){ drillSuccess('T-Spin completed!'); }
      if(clsMode.value==='drill_pc' && !state.board.some(r=>r.some(Boolean))){ drillSuccess('Perfect Clear!'); }

      popNext();
      canHold=true;
      if(!ensureSpawnValid()) return;
      updateDisplay();
    });
  } else {
    popNext();
    canHold=true;
    if(!ensureSpawnValid()) return;
    updateDisplay();
  }
}

/* ---------- DROPS & ROTATION ---------- */
function hardDrop(){
  let dist=0;
  while(move(0,1)) dist++;
  if(dist>0){
    state.score+=dist*HARD_POINT;
    roll.hard++;
  }
  lockPiece();
}

function rotateCurCW(){
  if(!state.cur) return;
  const r=srsRotateCW(state.cur);
  if(r.ok){
    state.cur.shape=r.shape;
    state.cur.x=r.x;
    state.cur.y=r.y;
    state.cur.o=r.o;
    lastActionWasRotate=true;
    lockSince=null;
    markInput();
  } else {
    roll.rotFail++;
  }
}

/* ---------- GRAVITY & ADAPTIVE ---------- */
function gravityInterval(){
  return Math.max(50, (INITIAL_SPEED - (state.level-1)*50) * slowMo);
}

let adaptClock=0;
function adaptTick(dt){
  if(!state.adaptive||state.gameOver||state.paused) return;
  adaptClock+=dt;
  if(adaptClock<12000) return;
  adaptClock=0;
  const age=(Date.now()-sessionStart)/1000;
  const lpm=state.lines/Math.max(1,age/60);
  const misRate=roll.mis/Math.max(1,roll.locks);
  const latency=roll.meanLatency||120;
  const comfort=(lpm/1.5)+(1-Math.min(1,misRate))+(120/Math.max(60,latency));
  if(comfort>=2.0){
    LOCK_DELAY=Math.max(200,LOCK_DELAY-40);
    state.queueSize=Math.max(3,state.queueSize-1);
  } else {
    LOCK_DELAY=Math.min(800,LOCK_DELAY+40);
    state.ghost=true;
    state.queueSize=Math.min(5,Math.max(3,state.queueSize));
  }
  optLock.value=String(LOCK_DELAY);
  drawNext();
}

/* ---------- MAIN LOOP ---------- */
function loop(ts){
  const dt=ts-lastTs;
  lastTs=ts;
  if(!state.paused && !state.gameOver){
    if(!animClearing){
      state.acc+=dt;
      const g=gravityInterval();
      while(state.acc>=g){
        state.acc-=g;
        if(!move(0,1)){
          const now=performance.now();
          if(lockSince===null) lockSince=now;
          if(now-lockSince>=LOCK_DELAY){ lockPiece(); }
          break;
        }
      }
      if(state.downHeld && move(0,1)){
        state.score+=SOFT_POINT;
        roll.soft++;
      }
      adaptTick(dt);
      updateDisplay();
    }
  }
  loopHandle=requestAnimationFrame(loop);
}

/* ---------- ANALYTICS & CSV ---------- */
function markInput(){
  const now=performance.now(), dt=now-roll.lastInputAt;
  roll.lastInputAt=now;
  roll.inputs++;
  roll.meanLatency=roll.meanLatency===0?dt:0.9*roll.meanLatency+0.1*dt;
}

function readAllRows(){ return safeReadJSON(CLASS_KEY, []); }

function writeAllRows(arr){
  while(arr.length>LOG_CAP) arr.shift();
  const ok=store.set(CLASS_KEY, JSON.stringify(arr));
  return ok;
}

function escCSV(s){
  const t=String(s??'');
  return /[",\n]/.test(t)?`"${t.replace(/"/g,'""')}"`:t;
}

function pushClassRow(status){
  const dur=Math.round((Date.now()-sessionStart)/1000);
  const row={
    ts:new Date().toISOString(),
    name:(playerName.value||'').slice(0,40),
    status,
    mode:clsMode.value,
    seed:lastStartedSeed??rngSeed,
    score:state.score,
    lines:state.lines,
    level:state.level,
    dur_s:dur,
    inputs:roll.inputs,
    latency_ms:Math.round(roll.meanLatency),
    soft:roll.soft,
    hard:roll.hard,
    mis:roll.mis,
    rotFail:roll.rotFail,
    locks:roll.locks,
    tspins:stats.tspins,
    perfects:stats.perfects
  };
  const arr=readAllRows();
  arr.push(row);
  if(!writeAllRows(arr)){
    console.warn('Failed to save logs');
  }
  updateBest(row);
}

function exportCSV(rows){
  const cols=["ts","name","status","mode","seed","score","lines","level","dur_s","inputs","latency_ms","soft","hard","mis","rotFail","locks","tspins","perfects"];
  const head=cols.join(",");
  const body=rows.map(r=>cols.map(k=>escCSV(r?.[k]??'')).join(",")).join("\n");
  const blob=new Blob([head+"\n"+body],{type:"text/csv"});
  const url=URL.createObjectURL(blob);
  const a=document.createElement("a");
  a.href=url;
  a.download="mc_tetris_classlog.csv";
  a.click();
  URL.revokeObjectURL(url);
}

function exportAll(){
  const rows=readAllRows();
  if(rows.length===0){ alert('No session data to export yet.'); return; }
  exportCSV(rows);
}

function exportMine(){
  const name=(playerName.value||'').slice(0,40);
  if(!name){ alert('Enter your name first to export your sessions.'); return; }
  const rows=readAllRows().filter(r=>(r.name||'').toLowerCase()===name.toLowerCase());
  if(rows.length===0){ alert('No sessions found for this name on this browser.'); return; }
  exportCSV(rows);
}

/* ---------- BESTS ---------- */
function readBest(){ return safeReadJSON(BEST_KEY, {}); }
function writeBest(b){ const ok=store.set(BEST_KEY, JSON.stringify(b)); return ok; }
function bestKey(name,mode){ return `${(name||'').trim().toLowerCase()}::${mode}`; }

function updateBest(row){
  const name=(row.name||'').trim();
  if(!name) return;
  const key=bestKey(name,row.mode);
  const all=readBest();
  const prev=all[key];
  if(!prev || row.score>prev.score){
    all[key]={score:row.score, lines:row.lines, level:row.level, ts:row.ts, mode:row.mode};
    writeBest(all);
  }
}

function getModeLabel(m){
  switch(m){
    case 'free': return 'Free Play';
    case 'timed120': return 'Timed (2m)';
    case 'drill_tspin': return 'Drill: T-Spin';
    case 'drill_pc': return 'Drill: Perfect Clear';
    default: return m;
  }
}

function showBests(){
  const all=readBest();
  const name=(playerName.value||'').trim().toLowerCase();
  const modes=['free','timed120','drill_tspin','drill_pc'];
  const rows=modes.map(m=>{
    const bk=bestKey(name,m), b=all[bk];
    if(!b) return `<li><b>${getModeLabel(m)}</b> — <span style="opacity:.7">no record yet</span></li>`;
    return `<li><b>${getModeLabel(m)}</b> — <b>${b.score}</b> pts • ${b.lines} lines • L${b.level} <span style="opacity:.7">(${new Date(b.ts).toLocaleString()})</span></li>`;
  }).join('');
  bestWrap.innerHTML=name?`<div><b>${playerName.value}</b> — Personal Bests</div><ul style="text-align:left;margin:.3rem 0 0 1rem">${rows}</ul>`:`<div style="opacity:.8">Enter your name to track progress.</div>`;
}

/* ---------- DRILL ---------- */
function drillSuccess(msg){
  alert(msg+'\n\nDrill completed! Starting new game...');
  gameOver();
}

/* ---------- TUTORIAL ---------- */
const tut={
  pages:[
    {title:'Welcome', body:'<p>Welcome to <b>MR. Scott\'s Block Fun</b> — Tetris for class.</p><p>Click the game board to enable keyboard controls.</p>'},
    {title:'Controls', body:'<p><b>Left/Right:</b> Move</p><p><b>Down:</b> Soft drop</p><p><b>Up/Space:</b> Rotate</p><p><b>Enter:</b> Hard drop</p><p><b>Shift/C:</b> Hold</p><p><b>P:</b> Pause</p><p><b>F:</b> Fullscreen</p>'},
    {title:'Modes', body:'<p><b>Free:</b> Play indefinitely</p><p><b>Timed:</b> 2-minute challenge</p><p><b>T-Spin Drill:</b> Master T-Spins</p><p><b>Perfect Clear:</b> Clear entire board</p>'},
    {title:'Scoring', body:'<p>Line clears scale with level.</p><p><b>T-Spins:</b> +400 bonus</p><p><b>Perfect Clear:</b> +1800 bonus</p>'},
    {title:'Tips', body:'<p>• Use deterministic seeds for consistency</p><p>• Adaptive mode adjusts difficulty</p><p>• Export your data as CSV</p><p>• Track personal bests</p>'}
  ],
  idx:0,
  show(){ this.idx=0; this.render(); tutorialModal.classList.remove('hidden'); },
  render(){
    const p=this.pages[this.idx];
    btns.tut.body.innerHTML=`<h3>${p.title}</h3>`+p.body;
    btns.tut.prev.disabled=this.idx===0;
    btns.tut.next.disabled=this.idx===this.pages.length-1;
  },
  next(){ if(this.idx<this.pages.length-1){ this.idx++; this.render(); }},
  prev(){ if(this.idx>0){ this.idx--; this.render(); }},
  exit(){ tutorialModal.classList.add('hidden'); }
};

/* ---------- KEYBINDS ---------- */
const DEFAULT_KEYS={left:'ArrowLeft', right:'ArrowRight', down:'ArrowDown', rotate:'ArrowUp', hard:'Enter', hold:'Shift', pause:'p'};
function loadKeys(){ return {...DEFAULT_KEYS, ...safeReadJSON('mc_kb', {})}; }
function saveKeys(map){ store.set('mc_kb',JSON.stringify(map)); }

let KEYS=loadKeys();

/* ---------- FULLSCREEN TOGGLE ---------- */
function toggleFullscreen(){
  isFullscreen=!isFullscreen;
  document.body.classList.toggle('fullscreen-mode', isFullscreen);
  fullscreenBtn.classList.toggle('hidden', isFullscreen);
  exitFullscreenBtn.classList.toggle('hidden', !isFullscreen);
  
  setTimeout(()=>{
    resizeCanvas();
    updateDisplay();
  }, 100);
}

fullscreenBtn.addEventListener('click',()=>{ toggleFullscreen(); });
exitFullscreenBtn.addEventListener('click',()=>{ toggleFullscreen(); });

/* Add F key to toggle fullscreen */
document.addEventListener('keydown',(e)=>{
  if(e.key.toLowerCase()==='f' && state.gameStarted && !state.paused){
    toggleFullscreen();
    e.preventDefault();
  }
});

/* ---------- INPUT HANDLING ---------- */
document.addEventListener('keydown',(e)=>{
  const tag=(document.activeElement && document.activeElement.tagName||'').toLowerCase();
  let handled=false;

  if(!state.gameStarted && !startModal.classList.contains('hidden') && (e.key===' '||e.key==='Enter') && tag!=='input' && tag!=='textarea'){
    startGame();
    handled=true;
  }

  if(state.gameStarted){
    const k=e.key.toLowerCase();
    if(k===KEYS.left.toLowerCase()){ move(-1,0); markInput(); handled=true; }
    else if(k===KEYS.right.toLowerCase()){ move(1,0); markInput(); handled=true; }
    else if(k===KEYS.down.toLowerCase()){ state.downHeld=true; handled=true; }
    else if(k===KEYS.rotate.toLowerCase() || e.key===' '){ rotateCurCW(); markInput(); handled=true; }
    else if(k===KEYS.hard.toLowerCase()){ hardDrop(); markInput(); handled=true; }
    else if(k===KEYS.hold.toLowerCase()){ holdSwap(); markInput(); handled=true; }
    else if(k===KEYS.pause.toLowerCase()){ togglePause(); handled=true; }
  }
  if(handled) e.preventDefault();
});

document.addEventListener('keyup',(e)=>{
  if(e.key.toLowerCase()===KEYS.down.toLowerCase()) state.downHeld=false;
});

window.addEventListener('blur',()=>{ state.downHeld=false; });

canvas.addEventListener('click',()=>{ canvas.focus(); });
canvas.addEventListener('focus',()=>{ console.log('[Game] Canvas focused'); });

/* ---------- BUTTON WIRING ---------- */
startBtn.addEventListener('click',()=>{ showBests(); startModal.classList.remove('hidden'); });
startModalStartBtn.addEventListener('click',()=>{ startGame(); });
startModalTutBtn.addEventListener('click',()=>{ tut.show(); });

pauseBtn.addEventListener('click',()=>{ togglePause(); });
rotateBtn.addEventListener('click',()=>{ rotateCurCW(); markInput(); });
dropBtn.addEventListener('click',()=>{ hardDrop(); markInput(); });
holdBtn.addEventListener('click',()=>{ holdSwap(); markInput(); });
keysBtn.addEventListener('click',()=>{ openKeybinds(); });
tutorialBtn.addEventListener('click',()=>{ tut.show(); });

exportBtn.addEventListener('click',()=>{ exportAll(); });
exportMineBtn.addEventListener('click',()=>{ exportMine(); });

gameOverRestartBtn.addEventListener('click',()=>{ startGame(); });
gameOverRetrySeedBtn.addEventListener('click',()=>{ retrySameSeed(); });

/* KEYBIND MODAL */
function openKeybinds(){
  btns.kb.left.value=KEYS.left;
  btns.kb.right.value=KEYS.right;
  btns.kb.down.value=KEYS.down;
  btns.kb.rotate.value=KEYS.rotate;
  btns.kb.hard.value=KEYS.hard;
  btns.kb.hold.value=KEYS.hold;
  btns.kb.pause.value=KEYS.pause;
  keysModal.classList.remove('hidden');
}

btns.kb.save.addEventListener('click',()=>{
  const map={
    left:btns.kb.left.value||DEFAULT_KEYS.left,
    right:btns.kb.right.value||DEFAULT_KEYS.right,
    down:btns.kb.down.value||DEFAULT_KEYS.down,
    rotate:btns.kb.rotate.value||DEFAULT_KEYS.rotate,
    hard:btns.kb.hard.value||DEFAULT_KEYS.hard,
    hold:btns.kb.hold.value||DEFAULT_KEYS.hold,
    pause:btns.kb.pause.value||DEFAULT_KEYS.pause
  };
  KEYS=map;
  saveKeys(map);
  keysModal.classList.add('hidden');
});

btns.kb.cancel.addEventListener('click',()=>{ keysModal.classList.add('hidden'); });

btns.tut.prev.addEventListener('click',()=>{ tut.prev(); });
btns.tut.next.addEventListener('click',()=>{ tut.next(); });
btns.tut.exit.addEventListener('click',()=>{ tut.exit(); });

optGhostAlpha.addEventListener('input',(e)=>{ ghostAlpha=parseFloat(e.target.value); });
clsZoom.addEventListener('change',()=>{ applyZoomSlow(); });
clsSlow.addEventListener('change',()=>{ applyZoomSlow(); });

/* ---------- LIFECYCLE ---------- */
function resetAnalytics(){
  stats.tspins=0;
  stats.perfects=0;
  roll.inputs=roll.soft=roll.hard=roll.mis=roll.locks=roll.rotFail=0;
  roll.meanLatency=0;
  roll.lastInputAt=performance.now();
}

function startWithSeed(seed){
  if(seed==='daily'){ rngSeed=dailySeed(); }
  else {
    const n=(+seed)||Math.floor(Math.random()*1e9);
    rngSeed=(n>>>0);
  }
  lastStartedSeed=rngSeed;
  startGame();
}

function retrySameSeed(){
  if(lastStartedSeed==null){
    alert('No seed in memory yet. Start a game first.');
    return;
  }
  startWithSeed(lastStartedSeed);
}

function applyZoomSlow(){
  const z=parseFloat(clsZoom.value)||1;
  const s=parseFloat(clsSlow.value)||1;
  slowMo=s;
  CSS_CELL=Math.round(32*z);
  resizeCanvas();
  updateDisplay();
  store.set('mc_zoom', String(z));
  store.set('mc_slow', String(s));
}

function startGame(){
  console.log('[Game] Starting game with mode:', clsMode.value);
  
  LOCK_DELAY=+optLock.value;
  const adaptive=optAdaptive.checked;
  const ghost=optGhost.checked;
  const symbolic=optSymbolic.checked;
  const qsize=5;
  
  const clsSel=clsSeed.value;
  if(clsSel==='daily'){
    rngSeed=dailySeed();
  } else if(/^\d+$/.test(clsSel)){
    rngSeed=(+clsSel)>>>0;
  } else {
    rngSeed=Math.floor(Math.random()*1e9)>>>0;
  }
  lastStartedSeed=rngSeed;

  state={
    board:[],
    cur:null,
    hold:null,
    score:0,
    lines:0,
    level:1,
    paused:false,
    gameOver:false,
    acc:0,
    downHeld:false,
    gameStarted:true,
    adaptive,
    ghost,
    symbolic,
    queueSize:qsize
  };

  sessionStart=Date.now();
  resetAnalytics();
  lastActionWasRotate=false;
  animClearing=false;

  makeBoard();
  queue=newBag();
  popNext();
  drawHold();
  drawNext();
  if(!ensureSpawnValid()) return;
  updateDisplay();

  startModal.classList.add('hidden');
  gameOverModal.classList.add('hidden');
  startBtn.classList.add('hidden');
  pauseBtn.classList.remove('hidden');

  cancelAnimationFrame(loopHandle);
  lastTs=performance.now();
  loopHandle=requestAnimationFrame(loop);

  canvas.focus();
  console.log('[Game] Game started, canvas focused');

  if(clsMode.value==='timed120'){
    const endAt=Date.now()+120000;
    const timer=setInterval(()=>{
      if(state.gameOver){ clearInterval(timer); return; }
      if(Date.now()>=endAt){
        clearInterval(timer);
        console.log('[Game] Timed mode ended');
        gameOver();
      }
    }, 250);
  }
}

function gameOver(){
  if(state.gameOver) return;
  state.gameOver=true;
  cancelAnimationFrame(loopHandle);
  
  console.log('[Game] Game Over - Score:', state.score, 'T-Spins:', stats.tspins);

  mustGet('finalScore').textContent=String(state.score);
  mustGet('finalLines').textContent=String(state.lines);
  mustGet('finalLevel').textContent=String(state.level);
  
  const secs=Math.max(1, Math.round((Date.now()-sessionStart)/1000));
  const lpm=(state.lines/(secs/60)).toFixed(1);
  mustGet('finalLPM').textContent=String(lpm);
  mustGet('finalTSpins').textContent=String(stats.tspins);
  mustGet('finalPCs').textContent=String(stats.perfects);
  
  gameOverModal.classList.remove('hidden');
  pauseBtn.classList.add('hidden');
  startBtn.classList.remove('hidden');
  
  if(isFullscreen) toggleFullscreen();
  
  pushClassRow('gameover');
}

function togglePause(){
  if(!state.gameStarted||state.gameOver) return;
  state.paused=!state.paused;
  if(state.paused){
    pauseModal.classList.remove('hidden');
    pauseBtn.textContent='RESUME';
    pushClassRow('pause');
  } else {
    pauseModal.classList.add('hidden');
    pauseBtn.textContent='PAUSE';
    lastTs=performance.now();
  }
}

playerName.addEventListener('input', ()=>{
  const nm=(playerName.value||'').slice(0,40);
  store.set(NAME_KEY, nm);
  showBests();
});

window.addEventListener('resize',()=>{ updateOrientHint(); resizeCanvas(); });

window.addEventListener('load',()=>{
  console.log('[Init] Initializing MC Tetris...');
  
  resizeCanvas();
  updateOrientHint();

  const savedName=store.get(NAME_KEY,'');
  if(savedName) playerName.value=savedName;
  
  const savedZoom=store.get('mc_zoom','');
  const savedSlow=store.get('mc_slow','');
  if(savedZoom) clsZoom.value=savedZoom;
  if(savedSlow) clsSlow.value=savedSlow;
  applyZoomSlow();

  startModal.classList.remove('hidden');
  showBests();

  console.log('[Init] MC Tetris ready!');
});

</script>
</body>
</html>

