<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>MC TETRIS — Classroom Canvas (Silent Edition)</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="preconnect" href="https://fonts.googleapis.com"/>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet"/>

<style>
:root{
  --ink:#0af7a3;
  --cyan:#07e1ff;
  --space:#070a16;
  --panel:#0b1220;
  --gridline: rgba(26,42,68,.55);
  --accent:#b6fff1;
}
*{box-sizing:border-box;margin:0;padding:0}
html,body{height:100%}
body{
  font-family:'JetBrains Mono',monospace;
  background:var(--space);color:#e6fff6;
  min-height:100vh;padding:1rem;overflow-x:hidden;position:relative;
}
.mc-bg{position:fixed;inset:0;z-index:-2;pointer-events:none;overflow:hidden}
.mc-art{position:absolute;inset:-2%;background:radial-gradient(120% 120% at 50% 10%, rgba(5,12,22,.92), rgba(3,8,16,1));filter:saturate(1.05) contrast(1.02) brightness(.95);animation:mcDrift 22s ease-in-out infinite alternate}
@keyframes mcDrift{from{transform:scale(1.02)}to{transform:scale(1.06) translate(-2%,2%)}}
.mc-aurora{position:absolute;inset:-10%;background:
  radial-gradient(40% 60% at 20% 10%, rgba(122,92,255,.22) 0%, transparent 60%),
  radial-gradient(48% 58% at 80% 0%, rgba(7,225,255,.18) 0%, transparent 60%),
  radial-gradient(46% 62% at 80% 80%, rgba(18,255,176,.18) 0%, transparent 70%);
filter:blur(28px) saturate(120%);animation:mcAurora 14s ease-in-out infinite alternate}
@keyframes mcAurora{0%{transform:none}100%{transform:translate(-2%,2%) scale(1.04)}}
.mc-scan{position:absolute;inset:0;background:linear-gradient(transparent 50%, rgba(0,0,0,.18) 50%);background-size:100% 3px;opacity:.22}
.mc-vignette{position:absolute;inset:0;background:radial-gradient(120% 120% at 50% 25%, transparent 55%, rgba(0,0,0,.45) 90%);mix-blend-mode:multiply}
.mc-watermark{position:absolute;right:12px;bottom:10px;user-select:none;font-weight:800;letter-spacing:.25rem;font-size:.7rem;color:rgba(18,255,176,.22)}

.container{max-width:1200px;margin:0 auto;position:relative}
.title{text-align:center;font-size:2.2rem;font-weight:800;letter-spacing:.3rem;margin-bottom:.6rem;color:var(--accent);text-shadow:0 0 12px var(--ink),0 0 26px var(--cyan)}
.subtitle{text-align:center;font-size:.9rem;opacity:.85;margin-bottom:1rem}

.game-layout{display:grid;grid-template-columns:1fr minmax(280px,360px) 1fr;gap:1rem;align-items:start}
.side-panel{
  background:linear-gradient(180deg, rgba(12,18,32,.82), rgba(8,12,24,.82));
  border:2px solid rgba(18,255,176,.5);border-radius:10px;padding:1rem;
  box-shadow:0 0 24px rgba(18,255,176,.25), inset 0 0 28px rgba(0,0,0,.35)
}
.panel-title{font-size:1rem;font-weight:800;text-align:center;margin:.3rem 0 .6rem}
.score-item{display:flex;justify-content:space-between;margin-bottom:.35rem;font-size:.95rem}
.score-value{color:var(--cyan);font-weight:800}

.game-board{
  border:4px solid rgba(18,255,176,.65);border-radius:10px;
  background:radial-gradient(120% 120% at 50% 10%, rgba(5,12,22,.92), rgba(3,8,16,1));
  box-shadow:0 0 24px rgba(18,255,176,.25), inset 0 0 28px rgba(0,0,0,.35);
  display:flex;justify-content:center;align-items:center;padding:4px
}
#gameCanvas{display:block;image-rendering:pixelated;max-width:100%;height:auto}

.mini-grid{width:96px;height:96px;border:2px solid #044;border-radius:6px;background:#000;margin:.35rem auto;
  display:grid;grid-template-columns:repeat(4,1fr);grid-template-rows:repeat(4,1fr);gap:1px;padding:3px}
.preview-cell{background:#000;border-radius:2px}
.mini-list{display:grid;grid-template-columns:1fr;gap:.35rem;justify-items:center}

.controls{display:grid;grid-template-columns:1fr 1fr;gap:.5rem}
.btn{
  background:rgba(10,16,28,.9);border:2px solid rgba(18,255,176,.6);color:#e6fff6;
  padding:.6rem .8rem;border-radius:8px;font-weight:700;cursor:pointer;transition:.15s;text-transform:uppercase;touch-action:manipulation
}
.btn:hover:not(:disabled){background:rgba(12,20,36,1);border-color:var(--cyan);box-shadow:0 0 12px rgba(7,225,255,.35)}
.btn:disabled{opacity:.55;cursor:not-allowed}
.btn-primary{background:linear-gradient(180deg,#0a3,#092);color:#fff;grid-column:span 2}
.btn-wide{grid-column:span 2}
.hidden{display:none!important}

.opt{display:grid;grid-template-columns:auto 1fr;gap:.45rem .6rem;align-items:center;font-size:.85rem;margin-top:.4rem}
.opt input[type="number"], .opt select, .opt input[type="text"]{
  background:#0a0a0a;color:#9fffbf;border:1px solid #044;border-radius:6px;padding:.35rem .4rem;width:100%
}
.opt input[type="range"]{width:100%}
.opt .hint{font-size:.75rem;opacity:.75;grid-column:span 2}

/* Modal */
.modal{position:fixed;inset:0;background:rgba(0,0,0,.88);display:flex;align-items:center;justify-content:center;z-index:1000;padding:1rem}
.modal-content{background:#111;border:4px solid rgba(18,255,176,.8);border-radius:12px;padding:1.2rem;text-align:center;max-width:760px;width:100%;box-shadow:0 0 30px rgba(0,255,176,.4)}
.modal-title{font-size:2rem;font-weight:900;margin-bottom:.4rem}
.modal-text{margin-bottom:.8rem;color:#aaf9ff}
.modal-stats{margin:.6rem 0;display:grid;grid-template-columns:repeat(3,1fr);gap:.6rem}
.stat-item{background:#000;border:1px solid #044;border-radius:8px;padding:.4rem}
.stat-value{font-size:1.1rem;font-weight:900;color:var(--cyan)}
.stat-label{font-size:.75rem;color:#0a0}

.kbd-grid{display:grid;grid-template-columns:1fr 1fr;gap:.5rem .6rem;margin-top:.4rem;text-align:left}
.kbd-grid label{font-size:.85rem}
.kbd-grid input{background:#0a0a0a;color:#9fffbf;border:1px solid #044;border-radius:6px;padding:.35rem .4rem}

.tut-body{text-align:left;font-size:.95rem;color:#9fffbf}
.tut-body .tut-list{margin-left:1rem;margin-top:.35rem;list-style:disc}
.tut-nav{display:flex;justify-content:center;gap:.6rem;margin-top:.6rem}

/* Colors */
.color-I{background:#00f0ff!important}
.color-O{background:#ffd900!important}
.color-T{background:#9d63ff!important}
.color-S{background:#15ff76!important}
.color-Z{background:#ff4b4b!important}
.color-J{background:#4a74ff!important}
.color-L{background:#ff9a2b!important}

/* Teacher overlay */
.teacher{background:var(--panel);border:2px solid rgba(18,255,176,.5);border-radius:10px;padding:.6rem;margin-top:.6rem}
.teacher h4{margin:.2rem 0 .4rem;font-size:1rem;text-align:center}
.teacher .row{display:grid;grid-template-columns:1fr 1fr;gap:.35rem}
.teacher small{opacity:.75}

/* Orientation hint */
#orientHint{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.9);color:#b6fff1;z-index:2000;text-align:center;padding:1rem}
#orientHint p{max-width:480px}

@media (max-width:1024px){
  .game-layout{grid-template-columns:1fr;gap:1rem}
  .title{font-size:2rem;letter-spacing:.2rem}
}
</style>
</head>

<body>
  <div class="mc-bg" aria-hidden="true">
    <div class="mc-art"></div>
    <div class="mc-aurora"></div>
    <div class="mc-scan"></div>
    <div class="mc-vignette"></div>
    <div class="mc-watermark">MCSTEPHEN</div>
  </div>

  <div class="container" role="application" aria-label="Tetris game">
    <h1 class="title">M C  T E T R I S</h1>
    <p class="subtitle">Silent classroom edition • deterministic seeds • CSV logs • teacher tools</p>

    <div class="game-layout">
      <!-- Left panel -->
      <aside class="side-panel" aria-label="Score and queue">
        <div class="panel-title">PLAYER</div>
        <div class="opt">
          <label for="playerName">Name</label>
          <input id="playerName" type="text" placeholder="e.g., Jordan A." maxlength="40"/>
        </div>

        <div class="panel-title" style="margin-top:.6rem;">SCORE</div>
        <div class="score-item"><span>Score</span><span class="score-value" id="score">0</span></div>
        <div class="score-item"><span>Lines</span><span class="score-value" id="lines">0</span></div>
        <div class="score-item"><span>Level</span><span class="score-value" id="level">1</span></div>

        <div class="panel-title" style="margin-top:.6rem;">HOLD</div>
        <div class="mini-grid" id="holdBox" aria-label="Hold preview"></div>

        <div class="panel-title" style="margin-top:.6rem;">NEXT</div>
        <div class="mini-list" id="nextList" aria-label="Next pieces">
          <div class="mini-grid"></div>
          <div class="mini-grid"></div>
          <div class="mini-grid"></div>
          <div class="mini-grid"></div>
          <div class="mini-grid"></div>
        </div>
      </aside>

      <!-- Board -->
      <main class="game-board" id="gameBoard">
        <canvas id="gameCanvas" aria-label="Game board" role="img"></canvas>
      </main>

      <!-- Right panel -->
      <aside class="side-panel" aria-label="Controls and options">
        <div class="panel-title">CONTROLS</div>
        <div class="controls" role="group" aria-label="Game controls">
          <button class="btn btn-primary" id="startBtn">START</button>
          <button class="btn hidden" id="pauseBtn">PAUSE</button>
          <button class="btn" id="rotateBtn">ROTATE</button>
          <button class="btn" id="dropBtn">HARD DROP</button>
          <button class="btn" id="holdBtn">HOLD</button>
          <button class="btn" id="keysBtn">KEY BINDS</button>
          <button class="btn" id="tutorialBtn">TUTORIAL</button>
          <button class="btn" id="exportBtn">EXPORT CSV (ALL)</button>
          <button class="btn" id="exportMineBtn">EXPORT MINE</button>
        </div>

        <div class="panel-title" style="margin-top:.6rem;">CLASSROOM MODE</div>
        <div class="opt" role="group" aria-label="Classroom options">
          <label>Mode</label>
          <select id="clsMode">
            <option value="free">Free Play</option>
            <option value="timed120">Timed — 2 minutes</option>
            <option value="drill_tspin">Drill — T-Spin Single</option>
            <option value="drill_pc">Drill — Perfect Clear</option>
          </select>

          <label>Lesson Seed</label>
          <select id="clsSeed">
            <option value="daily">Daily</option>
            <option value="123456">#123456</option>
            <option value="8675309">#8675309</option>
            <option value="424242">#424242</option>
            <option value="987654321">#987654321</option>
          </select>

          <label>Projector Mode</label>
          <select id="clsZoom">
            <option value="1">Normal</option>
            <option value="1.25">Large</option>
            <option value="1.5">XL</option>
          </select>

          <label>Slow Motion</label>
          <select id="clsSlow">
            <option value="1">Off</option>
            <option value="1.25">x1.25</option>
            <option value="1.5">x1.5</option>
            <option value="2">x2</option>
          </select>

          <div class="hint">Share URLs carry mode/seed/zoom/slow/name.</div>
        </div>

        <div class="panel-title" style="margin-top:.6rem;">OPTIONS</div>
        <div class="opt">
          <label><input type="checkbox" id="optAdaptive" checked/> Adaptive Mode</label><span></span>
          <label>Lock Delay</label><input type="range" id="optLock" min="200" max="800" value="500"/>
          <label>Daily Seed</label><input type="checkbox" id="optDaily"/>
          <label>Seed</label><input type="number" id="optSeed" value="0" min="0" step="1" inputmode="numeric"/>
          <label>Queue Size</label>
          <select id="optQueue"><option>5</option><option>4</option><option>3</option></select>
          <label><input type="checkbox" id="optGhost" checked/> Ghost Piece</label><span></span>
          <label>Ghost Opacity</label><input type="range" id="optGhostAlpha" min="0.1" max="0.6" step="0.05" value="0.25"/>
          <label><input type="checkbox" id="optSymbolic"/> Symbolic Score Boost</label><span></span>
        </div>

        <div class="teacher" aria-label="Teacher tools">
          <h4>Teacher Tools</h4>
          <div class="row">
            <button class="btn" id="btnResetLog" title="Clears ALL stored sessions for this browser">Reset Logs</button>
            <button class="btn" id="btnCopyURL">Copy Shareable URL</button>
            <button class="btn btn-wide" id="btnRetrySeed">Retry Same Seed</button>
          </div>
          <small>Tip: add <code>?mode=free&seed=daily&zoom=1.25&slow=1.5&name=Alex</code> to the URL.</small>
        </div>
      </aside>
    </div>

    <!-- Modals -->
    <div class="modal" id="startModal" aria-modal="true" role="dialog">
      <div class="modal-content">
        <div class="modal-title">T  E  T  R  I  S</div>
        <div class="modal-text">Silent classroom edition — smooth loop, deterministic seeds, teaching tools.</div>
        <div id="bestWrap" style="margin:.4rem 0 .2rem; font-size:.9rem; opacity:.85;"></div>
        <div style="display:flex; gap:.6rem; flex-wrap:wrap; justify-content:center;">
          <button class="btn" id="startModalTutBtn" style="min-width:160px;">TUTORIAL</button>
          <button class="btn btn-primary" id="startModalStartBtn" style="min-width:160px;">START GAME</button>
        </div>
        <div style="margin-top:.6rem; font-size:.8rem; opacity:.75;">Press SPACE or ENTER to start</div>
      </div>
    </div>

    <div class="modal hidden" id="gameOverModal" aria-modal="true" role="dialog">
      <div class="modal-content">
        <div class="modal-title">GAME OVER</div>
        <div class="modal-stats">
          <div class="stat-item"><div class="stat-value" id="finalScore">0</div><div class="stat-label">SCORE</div></div>
          <div class="stat-item"><div class="stat-value" id="finalLines">0</div><div class="stat-label">LINES</div></div>
          <div class="stat-item"><div class="stat-value" id="finalLevel">1</div><div class="stat-label">LEVEL</div></div>
          <div class="stat-item"><div class="stat-value" id="finalLPM">0</div><div class="stat-label">LPM</div></div>
          <div class="stat-item"><div class="stat-value" id="finalTSpins">0</div><div class="stat-label">T-SPINS</div></div>
          <div class="stat-item"><div class="stat-value" id="finalPCs">0</div><div class="stat-label">PERFECT CLEARS</div></div>
        </div>
        <div style="display:flex; gap:.6rem; flex-wrap:wrap; justify-content:center;">
          <button class="btn" id="gameOverRestartBtn" style="min-width:160px;">PLAY AGAIN</button>
          <button class="btn btn-primary" id="gameOverRetrySeedBtn" style="min-width:180px;">RETRY SAME SEED</button>
        </div>
        <div style="margin-top:.6rem; font-size:.8rem; opacity:.75;">Press SPACE or ENTER to start</div>
      </div>
    </div>

    <div class="modal hidden" id="pauseModal" aria-modal="true" role="dialog">
      <div class="modal-content">
        <div class="modal-title">PAUSED</div>
        <div class="modal-text">Press P or click PAUSE to continue.</div>
      </div>
    </div>

    <div class="modal hidden" id="keysModal" aria-modal="true" role="dialog">
      <div class="modal-content">
        <div class="modal-title">KEY BINDS</div>
        <div class="kbd-grid">
          <label>Left</label><input id="kbLeft"  placeholder="ArrowLeft"/>
          <label>Right</label><input id="kbRight" placeholder="ArrowRight"/>
          <label>Soft Drop</label><input id="kbDown"  placeholder="ArrowDown"/>
          <label>Rotate</label><input id="kbRotate" placeholder="ArrowUp / Space"/>
          <label>Hard Drop</label><input id="kbHard"  placeholder="Enter"/>
          <label>Hold</label><input id="kbHold"  placeholder="C / Shift"/>
          <label>Pause</label><input id="kbPause" placeholder="P"/>
        </div>
        <div style="display:flex; gap:.6rem; justify-content:center; margin-top:.6rem;">
          <button class="btn" id="kbCancel">Cancel</button>
          <button class="btn btn-primary" id="kbSave">Save</button>
        </div>
      </div>
    </div>

    <div class="modal hidden" id="tutorialModal" aria-modal="true" role="dialog">
      <div class="modal-content" style="max-width:720px;">
        <div class="modal-title">TUTORIAL</div>
        <div id="tutBody" class="tut-body"></div>
        <div class="tut-nav">
          <button class="btn" id="tutPrev">Back</button>
          <button class="btn" id="tutExit">Exit</button>
          <button class="btn btn-primary" id="tutNext">Next</button>
        </div>
      </div>
    </div>
  </div>

  <div id="orientHint"><p>For a better classroom experience, rotate your device to <b>landscape</b> or use a wider window.</p></div>
<script>
/* ===========================================================
   MC TETRIS — Classroom Canvas (SILENT, fixed, teachable)
   Part 2 / 4: Core engine, rendering, movement, rotation, loop
   =========================================================== */

/* ---------- Utilities ---------- */
function mustGet(id){ const el=document.getElementById(id); if(!el) throw new Error('Missing #' + id); return el; }
const store = {
  get:(k,f="{}")=>{ try{ return localStorage.getItem(k) ?? f }catch{ return f } },
  set:(k,v)=>{ try{ localStorage.setItem(k,v); return true } catch(e){ console.error('Storage error:',e); alert('Local storage is full or unavailable — logs/settings may not be saved.'); return false } }
};
const clamp=(v,min,max)=>Math.min(max,Math.max(min,v));
function safeReadJSON(key, fallback){
  try{ const raw=store.get(key, JSON.stringify(fallback)); const parsed=JSON.parse(raw); return Array.isArray(parsed)||typeof parsed==='object'?parsed:fallback; }
  catch{ return fallback; }
}

/* ---------- Constants ---------- */
const BOARD_WIDTH = 10, BOARD_HEIGHT = 20;
let CSS_CELL = 32;
const INITIAL_SPEED=500; // ms per step @ level 1
let LOCK_DELAY=500;
const SOFT_POINT=1, HARD_POINT=2;
const LINE_SCORE=[0,100,300,500,800];
const TSPIN_BONUS=400, PERFECT_CLEAR_BONUS=1800;
const CLASS_KEY='mc_tetris_classlog';
const BEST_KEY='mc_tetris_best';
const LOG_CAP=500;
const VALID_MODES = ['free','timed120','drill_tspin','drill_pc'];

/* ---------- Canvas + Grid cache ---------- */
const canvas = mustGet('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
let gridLayer=null, gridLayerCtx=null;

function buildGridLayer(){
  gridLayer=document.createElement('canvas');
  gridLayer.width=BOARD_WIDTH*CSS_CELL;
  gridLayer.height=BOARD_HEIGHT*CSS_CELL;
  gridLayerCtx=gridLayer.getContext('2d',{alpha:false});
  // background
  gridLayerCtx.fillStyle='#000';
  gridLayerCtx.fillRect(0,0,gridLayer.width,gridLayer.height);
  // grid lines
  gridLayerCtx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--gridline') || 'rgba(26,42,68,.55)';
  gridLayerCtx.lineWidth=1;
  for(let x=0;x<=BOARD_WIDTH;x++){
    gridLayerCtx.beginPath(); gridLayerCtx.moveTo(x*CSS_CELL,0); gridLayerCtx.lineTo(x*CSS_CELL,BOARD_HEIGHT*CSS_CELL); gridLayerCtx.stroke();
  }
  for(let y=0;y<=BOARD_HEIGHT;y++){
    gridLayerCtx.beginPath(); gridLayerCtx.moveTo(0,y*CSS_CELL); gridLayerCtx.lineTo(BOARD_WIDTH*CSS_CELL,y*CSS_CELL); gridLayerCtx.stroke();
  }
}

function resizeCanvas() {
  const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const cssW = Math.floor(BOARD_WIDTH * CSS_CELL);
  const cssH = Math.floor(BOARD_HEIGHT * CSS_CELL);
  canvas.style.width = cssW + 'px';
  canvas.style.height = cssH + 'px';
  canvas.width = cssW * dpr;
  canvas.height = cssH * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  buildGridLayer();
}

/* ---------- Orientation hint ---------- */
const orientHint = mustGet('orientHint');
function updateOrientHint(){
  const w=window.innerWidth, h=window.innerHeight;
  const show = w<h && w<700;
  orientHint.style.display = show ? 'flex' : 'none';
}

/* ---------- DOM refs ---------- */
const startModal=mustGet('startModal');
const gameOverModal=mustGet('gameOverModal');
const pauseModal=mustGet('pauseModal');
const keysModal=mustGet('keysModal');
const tutorialModal=mustGet('tutorialModal');

const startBtn=mustGet('startBtn');
const startModalStartBtn=mustGet('startModalStartBtn');
const startModalTutBtn=mustGet('startModalTutBtn');
const gameOverRestartBtn=mustGet('gameOverRestartBtn');
const gameOverRetrySeedBtn=mustGet('gameOverRetrySeedBtn');

const pauseBtn=mustGet('pauseBtn');
const rotateBtn=mustGet('rotateBtn');
const dropBtn=mustGet('dropBtn');
const holdBtn=mustGet('holdBtn');
const keysBtn=mustGet('keysBtn');
const tutorialBtn=mustGet('tutorialBtn');
const exportBtn=mustGet('exportBtn');
const exportMineBtn=mustGet('exportMineBtn');

const scoreEl=mustGet('score');
const linesEl=mustGet('lines');
const levelEl=mustGet('level');
const holdBox=mustGet('holdBox');
const nextList=mustGet('nextList');

const playerName=mustGet('playerName');

const optAdaptive=mustGet('optAdaptive');
const optLock=mustGet('optLock');
const optDaily=mustGet('optDaily');
const optSeed=mustGet('optSeed');
const optQueue=mustGet('optQueue');
const optGhost=mustGet('optGhost');
const optGhostAlpha=mustGet('optGhostAlpha');
const optSymbolic=mustGet('optSymbolic');

const clsMode=mustGet('clsMode');
const clsSeed=mustGet('clsSeed');
const clsZoom=mustGet('clsZoom');
const clsSlow=mustGet('clsSlow');

const btnResetLog=mustGet('btnResetLog');
const btnCopyURL=mustGet('btnCopyURL');
const btnRetrySeed=mustGet('btnRetrySeed');

const bestWrap=mustGet('bestWrap');

/* ---------- Colors & pieces ---------- */
const COLOR_MAP = {
  'color-I': '#00f0ff',
  'color-O': '#ffd900',
  'color-T': '#9d63ff',
  'color-S': '#15ff76',
  'color-Z': '#ff4b4b',
  'color-J': '#4a74ff',
  'color-L': '#ff9a2b'
};

const TETROMINOES={
  I:{shape:[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],class:'color-I',id:1},
  O:{shape:[[1,1],[1,1]],class:'color-O',id:3},
  T:{shape:[[0,1,0],[1,1,1],[0,0,0]],class:'color-T',id:2},
  S:{shape:[[0,1,1],[1,1,0],[0,0,0]],class:'color-S',id:4},
  Z:{shape:[[1,1,0],[0,1,1],[0,0,0]],class:'color-Z',id:5},
  J:{shape:[[1,0,0],[1,1,1],[0,0,0]],class:'color-J',id:6},
  L:{shape:[[0,0,1],[1,1,1],[0,0,0]],class:'color-L',id:7}
};
const TYPES=Object.keys(TETROMINOES);

/* SRS kick data */
const SRS_JLSTZ = {
  '0>1': [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
  '1>0': [[0,0],[1,0],[1,1],[0,-2],[1,-2]],
  '1>2': [[0,0],[1,0],[1,1],[0,-2],[1,-2]],
  '2>1': [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
  '2>3': [[0,0],[1,0],[1,-1],[0,2],[1,2]],
  '3>2': [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
  '3>0': [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
  '0>3': [[0,0],[1,0],[1,-1],[0,2],[1,2]]
};
const SRS_I = {
  '0>1': [[0,0],[-2,0],[1,0],[-2,1],[1,-2]],
  '1>0': [[0,0],[2,0],[-1,0],[2,-1],[-1,2]],
  '1>2': [[0,0],[-1,0],[2,0],[-1,-2],[2,1]],
  '2>1': [[0,0],[1,0],[-2,0],[1,2],[-2,-1]],
  '2>3': [[0,0],[2,0],[-1,0],[2,-1],[-1,2]],
  '3>2': [[0,0],[-2,0],[1,0],[-2,1],[1,-2]],
  '3>0': [[0,0],[1,0],[-2,0],[1,2],[-2,-1]],
  '0>3': [[0,0],[-1,0],[2,0],[-1,-2],[2,1]]
};

/* ---------- RNG ---------- */
let rngSeed=(Math.random()*1e9)>>>0;
function dailySeed(){ const d=new Date(); return (d.getFullYear()*10000+(d.getMonth()+1)*100+d.getDate())>>>0; }
function xs32(){ rngSeed^=rngSeed<<13; rngSeed^=rngSeed>>>17; rngSeed^=rngSeed<<5; return (rngSeed>>>0)/0xffffffff; }
function newBag(){ const arr=[1,2,3,4,5,6,7]; for(let i=arr.length-1;i>0;i++){ const j=Math.floor(xs32()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr.map(id=>TYPES.find(k=>TETROMINOES[k].id===id)); }

/* ---------- State ---------- */
let state={};
let queue=[], canHold=true, lockSince=null, loopHandle=0;
let lastActionWasRotate=false, animClearing=false;
let safetyTimerId=null, ghostAlpha=0.25;
let sessionStart=Date.now();
const stats={ tspins:0, perfects:0 };
const roll={ inputs:0, soft:0, hard:0, mis:0, locks:0, rotFail:0, lastInputAt:performance.now(), meanLatency:0 };
let lastTs=performance.now(), lastStartedSeed=null;
let slowMo=1;

/* ---------- Helpers ---------- */
function makeBoard(){ state.board=Array.from({length:BOARD_HEIGHT},()=>Array.from({length:BOARD_WIDTH},()=>null)); }
function spawnPiece(t){ const d=TETROMINOES[t]; return {type:t,class:d.class,o:0,shape:d.shape.map(r=>r.slice()),x:Math.floor(BOARD_WIDTH/2)-Math.floor(d.shape[0].length/2),y:-1}; }
function currentCells(p){ const a=[]; for(let py=0;py<p.shape.length;py++) for(let px=0;px<p.shape[py].length;px++) if(p.shape[py][px]) a.push({x:p.x+px,y:p.y+py}); return a; }
function validAt(board,p,X,Y,shapeOverride=null){
  const shp=shapeOverride||p.shape;
  for(let py=0;py<shp.length;py++) for(let px=0;px<shp[py].length;px++) if(shp[py][px]){
    const x=X+px, y=Y+py;
    if(x<0||x>=BOARD_WIDTH||y>=BOARD_HEIGHT) return false;
    if(y>=0 && board[y][x]) return false;
  }
  return true;
}
function rotCW(shape){ const r=shape.length,c=shape[0].length,out=Array.from({length:c},()=>Array(r).fill(0)); for(let i=0;i<r;i++) for(let j=0;j<c;j++) out[j][r-1-i]=shape[i][j]; return out; }
function srsRotateCW(p){
  const from=p.o,to=(p.o+1)&3, cand=rotCW(p.shape);
  if(p.type==='O'){ if(validAt(state.board,p,p.x,p.y,cand)) return {ok:true,x:p.x,y:p.y,shape:cand,o:to}; return {ok:false}; }
  const table=(p.type==='I')?SRS_I:SRS_JLSTZ, kicks=table[`${from}>${to}`];
  for(const [dx,dy] of kicks){ const nx=p.x+dx, ny=p.y+dy; if(validAt(state.board,p,nx,ny,cand)) return {ok:true,x:nx,y:ny,shape:cand,o:to}; }
  return {ok:false};
}
function ghostY(board,p){ let y=p.y; while(validAt(board,p,p.x,y+1)) y++; return y; }

/* ---------- UI mini previews ---------- */
function miniGrid(el,shape,cls){ el.innerHTML=''; for(let y=0;y<4;y++) for(let x=0;x<4;x++){ const c=document.createElement('div'); c.className='preview-cell'; if(shape?.[y]?.[x]) c.classList.add(cls); el.appendChild(c);} }
function drawHold(){ const h=state.hold?TETROMINOES[state.hold.type]:null; const sh=h?h.shape:[[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]; miniGrid(holdBox,sh,h?h.class:''); }
function drawNext(){
  const minis=[...nextList.querySelectorAll('.mini-grid')];
  minis.forEach((m,i)=>{ m.style.display=(i<(state.queueSize||5))?'':'none'; });
  for(let i=0;i<minis.length;i++){
    const t=queue[i], d=t?TETROMINOES[t]:null, blank=[[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]];
    miniGrid(minis[i], d?d.shape:blank, d?d.class:'');
  }
}

/* ---------- Rendering ---------- */
function drawCell(x,y,cls,alpha=1){
  const color = COLOR_MAP[cls] || '#fff';
  const px=x*CSS_CELL, py=y*CSS_CELL;
  ctx.globalAlpha=alpha;
  ctx.fillStyle=color;
  ctx.fillRect(px+1,py+1,CSS_CELL-2,CSS_CELL-2);
  ctx.fillStyle='rgba(255,255,255,0.28)';
  ctx.fillRect(px+1,py+1,CSS_CELL-2,Math.floor(CSS_CELL/3));
  ctx.fillStyle='rgba(0,0,0,0.22)';
  ctx.fillRect(px+1,py+CSS_CELL-Math.floor(CSS_CELL/3),CSS_CELL-2,Math.floor(CSS_CELL/3));
  ctx.globalAlpha=1;
}
function drawBoard(){
  ctx.drawImage(gridLayer,0,0);
  // board tiles
  for(let y=0;y<BOARD_HEIGHT;y++) for(let x=0;x<BOARD_WIDTH;x++) if(state.board[y][x]) drawCell(x,y,state.board[y][x]);
  // ghost (suppressed during clear anim)
  if(state.ghost && state.cur && !animClearing){
    const gy=ghostY(state.board,state.cur);
    for(const {x,y} of currentCells({...state.cur,y:gy})){ if(y>=0) drawCell(x,y,state.cur.class,ghostAlpha); }
  }
  // current piece
  if(state.cur){ for(const {x,y} of currentCells(state.cur)){ if(y>=0) drawCell(x,y,state.cur.class); } }
  // lock pulse
  if(lockSince!==null && state.cur){
    const pulse=Math.sin((performance.now()-lockSince)/100)*0.2+0.8;
    ctx.globalAlpha=pulse;
    for(const {x,y} of currentCells(state.cur)){ if(y>=0){ ctx.fillStyle='rgba(255,255,255,0.3)'; ctx.fillRect(x*CSS_CELL,y*CSS_CELL,CSS_CELL,CSS_CELL); } }
    ctx.globalAlpha=1;
  }
}
function updateDisplay(){ drawBoard(); scoreEl.textContent=String(state.score); linesEl.textContent=String(state.lines); levelEl.textContent=String(state.level); }

/* ---------- Queue & moves ---------- */
function popNext(){ while(queue.length<7) queue=queue.concat(newBag()); const type=queue.shift(); state.cur=spawnPiece(type); lastActionWasRotate=false; lockSince=null; drawNext(); }
function ensureSpawnValid(){ if(!validAt(state.board,state.cur,state.cur.x,state.cur.y)){ gameOver(); return false; } return true; }
function holdSwap(){ if(!canHold||!state.cur) return; const curType=state.cur.type; if(!state.hold){ state.hold={type:curType}; popNext(); } else { const swap=state.hold.type; state.hold={type:curType}; state.cur=spawnPiece(swap); } canHold=false; lastActionWasRotate=false; lockSince=null; drawHold(); if(!ensureSpawnValid()) return; updateDisplay(); }
function move(dx,dy){
  if(!state.cur) return false;
  const nx=state.cur.x+dx, ny=state.cur.y+dy;
  if(validAt(state.board,state.cur,nx,ny)){
    state.cur.x=nx; state.cur.y=ny;
    if(dy>0) lastActionWasRotate=false;
    return true;
  }
  if(dx!==0) roll.mis++;
  return false;
}
function filledRows(){ const rows=[]; for(let y=0;y<BOARD_HEIGHT;y++) if(state.board[y].every(Boolean)) rows.push(y); return rows; }

/* ---------- T-Spin (simple check) ---------- */
function isTSpin(){ 
  if(!lastActionWasRotate || state.cur?.type!=='T') return false; 
  const c={x:state.cur.x+1,y:state.cur.y+1};
  const corners=[{x:c.x-1,y:c.y-1},{x:c.x+1,y:c.y-1},{x:c.x-1,y:c.y+1},{x:c.x+1,y:c.y+1}];
  const filled=corners.filter(({x,y})=> x<0||x>=BOARD_WIDTH||y<0||y>=BOARD_HEIGHT||state.board[y]?.[x]).length; 
  return filled>=3; 
}

/* ---------- Race-safe line clear ---------- */
function animateClearAndApply(rows, onDone){
  animClearing=true;
  let flashCount=0; const maxFlashes=6;
  const iv=setInterval(()=>{
    flashCount++;
    for(const y of rows){
      for(let x=0;x<BOARD_WIDTH;x++){
        ctx.fillStyle = (flashCount % 2 === 0) ? '#9dff9d' : '#ffffff';
        ctx.fillRect(x * CSS_CELL + 1, y * CSS_CELL + 1, CSS_CELL - 2, CSS_CELL - 2);
      }
    }
    if(flashCount>=maxFlashes){
      clearInterval(iv);
      const sorted=rows.slice().sort((a,b)=>b-a);
      for(const y of sorted){
        state.board.splice(y,1);
        state.board.unshift(Array(BOARD_WIDTH).fill(null));
      }
      animClearing=false;
      onDone && onDone();
    }
  }, 70);
}

/* ---------- Lock & scoring ---------- */
function lockPiece(){
  const p=state.cur;
  for(let py=0;py<p.shape.length;py++) for(let px=0;px<p.shape[py].length;px++) if(p.shape[py][px]){ const x=p.x+px, y=p.y+py; if(y>=0) state.board[y][x]=p.class; }
  roll.locks++; lockSince=null;

  const rows=filledRows(); 
  const tspin=isTSpin(); 
  const hadBlocks=state.board.some(r=>r.some(Boolean));

  if(rows.length>0){
    animateClearAndApply(rows, ()=>{
      const oldLevel=state.level;
      let gained=LINE_SCORE[rows.length]*Math.max(1,state.level);
      if(tspin){ gained+=TSPIN_BONUS; stats.tspins++; }
      if(!state.board.some(r=>r.some(Boolean))&&hadBlocks){ gained+=PERFECT_CLEAR_BONUS; stats.perfects++; }
      if(state.symbolic){ const misRate=roll.mis/Math.max(1,roll.locks); const mult=Math.max(1,1+0.15*(1-Math.min(1,misRate))); gained=Math.round(gained*mult); }
      state.score+=gained; state.lines+=rows.length; state.level=Math.floor(state.lines/10)+1;

      popNext(); canHold=true;
      if(!ensureSpawnValid()) return;
      updateDisplay();
      if(tut.practiceMode && tspin) tutAdvance();
    });
  } else {
    popNext(); canHold=true;
    if(!ensureSpawnValid()) return;
    updateDisplay();
  }
}

/* ---------- Drops & rotation ---------- */
function hardDrop(){ let dist=0; while(move(0,1)) dist++; if(dist>0){ state.score+=dist*HARD_POINT; roll.hard++; } lockPiece(); }
function rotateCurCW(){ if(!state.cur) return; const r=srsRotateCW(state.cur); if(r.ok){ state.cur.shape=r.shape; state.cur.x=r.x; state.cur.y=r.y; state.cur.o=r.o; lastActionWasRotate=true; lockSince=null; updateDisplay(); } else { roll.rotFail++; } }

/* ---------- Gravity & adaptive ---------- */
function gravityInterval(){ return Math.max(50, (INITIAL_SPEED - (state.level-1)*50) * slowMo); }
let adaptClock=0;
function adaptTick(dt){
  if(!state.adaptive||state.gameOver||state.paused) return; 
  adaptClock+=dt; if(adaptClock<12000) return; adaptClock=0;
  const age=(Date.now()-sessionStart)/1000, lpm=state.lines/Math.max(1,age/60);
  const misRate=roll.mis/Math.max(1,roll.locks), latency=roll.meanLatency||120;
  const comfort=(lpm/1.5)+(1-Math.min(1,misRate))+(120/Math.max(60,latency));
  if(comfort>=2.0){
    LOCK_DELAY=Math.max(200,LOCK_DELAY-40);
    state.queueSize=Math.max(3,state.queueSize-1);
  } else {
    LOCK_DELAY=Math.min(800,LOCK_DELAY+40);
    state.ghost=true;
    state.queueSize=Math.min(5,Math.max(3,state.queueSize));
  }
  optLock.value=String(LOCK_DELAY); drawNext();
}

/* ---------- Main loop ---------- */
function loop(ts){
  const dt=ts-lastTs; lastTs=ts;

  if(!state.paused && !state.gameOver){
    if(!animClearing){
      state.acc+=dt; const g=gravityInterval();
      while(state.acc>=g){
        state.acc-=g;
        if(!move(0,1)){
          const now=performance.now(); if(lockSince===null) lockSince=now;
          if(now-lockSince>=LOCK_DELAY){ lockPiece(); }
          break;
        }
      }
      if(state.downHeld && move(0,1)){ state.score+=SOFT_POINT; roll.soft++; }
      adaptTick(dt);
      updateDisplay();
    }
  }
  loopHandle=requestAnimationFrame(loop);
}


</script
  <script>
/* ===========================================================
   MC TETRIS — Classroom Canvas (Silent Edition)
   Part 3 / 4: Metrics/CSV, bests, lifecycle, drills, keys,
               URL params + bindings
   =========================================================== */

/* ---------- Metrics & CSV ---------- */
function markInput(){
  const now=performance.now(), dt=now-roll.lastInputAt;
  roll.lastInputAt=now; roll.inputs++;
  roll.meanLatency = roll.meanLatency===0 ? dt : 0.9*roll.meanLatency + 0.1*dt;
}

function readAllRows(){
  return safeReadJSON(CLASS_KEY, []);
}
function writeAllRows(arr){
  // rotation cap + quota safety
  while(arr.length>LOG_CAP) arr.shift();
  const ok=store.set(CLASS_KEY, JSON.stringify(arr));
  if(!ok) console.warn('Failed to save logs (quota?)');
  return ok;
}

function escCSV(s){
  const t=String(s??'');
  if(/[",\n]/.test(t)) return `"${t.replace(/"/g,'""')}"`;
  return t;
}

function pushClassRow(status){
  const dur=Math.round((Date.now()-sessionStart)/1000);
  const row={
    ts:new Date().toISOString(),
    name:(playerName.value||'').slice(0,40),
    status,
    mode:clsMode.value,
    seed:lastStartedSeed ?? rngSeed,
    score:state.score,
    lines:state.lines,
    level:state.level,
    dur_s:dur,
    inputs:roll.inputs,
    latency_ms:Math.round(roll.meanLatency),
    soft:roll.soft, hard:roll.hard, mis:roll.mis,
    rotFail:roll.rotFail, locks:roll.locks,
    tspins:stats.tspins, perfects:stats.perfects
  };
  const arr=readAllRows();
  arr.push(row);
  if(!writeAllRows(arr)){
    alert('Logs not saved (browser storage full). Consider exporting & resetting logs.');
  }
  updateBest(row);
}

function exportCSV(rows){
  const cols=["ts","name","status","mode","seed","score","lines","level","dur_s","inputs","latency_ms","soft","hard","mis","rotFail","locks","tspins","perfects"];
  const head=cols.join(",");
  const body=rows.map(r=>cols.map(k=>escCSV(r?.[k]??"")).join(",")).join("\n");
  const blob=new Blob([head+"\n"+body],{type:"text/csv"});
  const url=URL.createObjectURL(blob);
  const a=document.createElement("a");
  a.href=url; a.download="mc_tetris_classlog.csv"; a.click();
  URL.revokeObjectURL(url);
}

function exportAll(){ const rows=readAllRows(); if(rows.length===0){ alert('No session data to export yet.'); return; } exportCSV(rows); }
function exportMine(){
  const name=(playerName.value||'').slice(0,40);
  if(!name){ alert('Enter your name first to export your sessions.'); return; }
  const rows=readAllRows().filter(r=>r.name===name);
  if(rows.length===0){ alert('No sessions found for this name on this browser.'); return; }
  exportCSV(rows);
}

/* ---------- Personal bests / leaderboard (local) ---------- */
function readBest(){ return safeReadJSON(BEST_KEY, {}); }
function writeBest(b){ const ok=store.set(BEST_KEY, JSON.stringify(b)); if(!ok) console.warn('Failed to save bests'); return ok; }
function bestKey(name,mode){ return `${(name||'').trim().toLowerCase()}::${mode}`; }

function updateBest(row){
  const name=(row.name||'').trim();
  if(!name) return;
  const key=bestKey(name,row.mode);
  const all=readBest();
  const prev=all[key];
  if(!prev || row.score>prev.score){
    all[key]={ score:row.score, lines:row.lines, level:row.level, ts:row.ts, mode:row.mode };
    writeBest(all);
  }
}

function getModeLabel(m){
  switch(m){
    case 'free': return 'Free Play';
    case 'timed120': return 'Timed (2m)';
    case 'drill_tspin': return 'Drill: T-Spin';
    case 'drill_pc': return 'Drill: Perfect Clear';
    default: return m;
  }
}

function showBests(){
  const all=readBest();
  const name=(playerName.value||'').trim().toLowerCase();
  const modes=['free','timed120','drill_tspin','drill_pc'];
  const rows=modes.map(m=>{
    const bk=bestKey(name,m), b=all[bk];
    if(!b) return `<li><b>${getModeLabel(m)}</b> — <span style="opacity:.7">no record yet</span></li>`;
    return `<li><b>${getModeLabel(m)}</b> — <b>${b.score}</b> pts • ${b.lines} lines • L${b.level} <span style="opacity:.7">(${new Date(b.ts).toLocaleString()})</span></li>`;
  }).join('');
  bestWrap.innerHTML = name ? `<div><b>${playerName.value}</b> — Personal Bests</div><ul style="text-align:left;margin:.3rem 0 0 1rem">${rows}</ul>` : `<div style="opacity:.8">Enter your name to track personal bests.</div>`;
}

/* ---------- URL params (validated) & sharing ---------- */
function parseAndApplyURL(){
  const p=new URLSearchParams(location.search);

  if(p.has('name')) playerName.value = p.get('name').slice(0,40);

  if(p.has('mode')){
    const m=p.get('mode');
    if(VALID_MODES.includes(m)) clsMode.value=m;
  }
  if(p.has('seed')){
    const s=p.get('seed');
    if(s==='daily'){ clsSeed.value='daily'; optDaily.checked=true; }
    else if(/^\d{1,10}$/.test(s)){ clsSeed.value=s; optDaily.checked=false; optSeed.value=String(+s); }
  }
  if(p.has('zoom')){
    const z=p.get('zoom');
    if(['1','1.25','1.5'].includes(z)) clsZoom.value=z;
  }
  if(p.has('slow')){
    const sl=p.get('slow');
    if(['1','1.25','1.5','2'].includes(sl)) clsSlow.value=sl;
  }
}

function shareableURL(){
  const url=new URL(location.href);
  const params=url.searchParams;
  const name=(playerName.value||'').slice(0,40);
  if(name) params.set('name',name); else params.delete('name');
  params.set('mode', clsMode.value);
  const sd = (optDaily.checked ? 'daily' : (String(+optSeed.value||0)));
  params.set('seed', sd);
  params.set('zoom', clsZoom.value);
  params.set('slow', clsSlow.value);
  url.search = params.toString();
  return url.toString();
}

/* ---------- Lifecycle: start/pause/over ---------- */
function resetAnalytics(){
  stats.tspins=0; stats.perfects=0;
  roll.inputs=roll.soft=roll.hard=roll.mis=roll.locks=roll.rotFail=0;
  roll.meanLatency=0; roll.lastInputAt=performance.now();
}

function startWithSeed(seed){
  // seed may be "daily" or number
  if(seed==='daily'){ rngSeed=dailySeed(); optDaily.checked=true; }
  else { const n=(+seed)||Math.floor(Math.random()*1e9); rngSeed=(n>>>0); optDaily.checked=false; optSeed.value=String(n); }
  lastStartedSeed=rngSeed;
  startGame();
}

function retrySameSeed(){
  if(lastStartedSeed==null){ alert('No seed in memory yet. Start a game first.'); return; }
  startWithSeed(lastStartedSeed);
}

function applyZoomSlow(){
  const z=parseFloat(clsZoom.value)||1;
  const s=parseFloat(clsSlow.value)||1;
  slowMo = s;
  // scale CSS cell size for projector feel, keep DPR scaling
  CSS_CELL = Math.round(32*z);
  resizeCanvas();
  updateDisplay();
  store.set('mc_zoom', String(z));
  store.set('mc_slow', String(s));
}

function startGame(){
  LOCK_DELAY=+optLock.value;
  const adaptive=optAdaptive.checked, ghost=optGhost.checked, symbolic=optSymbolic.checked, qsize=+optQueue.value;
  // seed choice priority: classroom select first
  const clsSel=clsSeed.value;
  if(clsSel==='daily'){ rngSeed=dailySeed(); optDaily.checked=true; }
  else if(/^\d+$/.test(clsSel)){ rngSeed=(+clsSel)>>>0; optDaily.checked=false; optSeed.value=String(rngSeed); }
  else { rngSeed = optDaily.checked ? dailySeed() : ((+optSeed.value)||Math.floor(Math.random()*1e9))>>>0; }
  lastStartedSeed=rngSeed;

  state={ board:[], cur:null, hold:null, score:0, lines:0, level:1, paused:false, gameOver:false,
          acc:0, downHeld:false, gameStarted:true, adaptive, ghost, symbolic, queueSize:qsize };

  sessionStart=Date.now();
  resetAnalytics();
  lastActionWasRotate=false; animClearing=false;

  makeBoard(); queue=newBag(); popNext(); drawHold(); drawNext(); if(!ensureSpawnValid()) return; updateDisplay();

  startModal.classList.add('hidden'); gameOverModal.classList.add('hidden');
  startBtn.classList.add('hidden'); pauseBtn.classList.remove('hidden');

  cancelAnimationFrame(loopHandle); lastTs=performance.now(); loopHandle=requestAnimationFrame(loop);

  clearTimeout(safetyTimerId);
  safetyTimerId=setTimeout(()=>{ 
    if(state.gameStarted && !state.gameOver && !state.paused){ 
      console.error('Safety timeout'); 
      cancelAnimationFrame(loopHandle); 
      alert('Game encountered an unexpected stall and has been stopped.'); 
    } 
  }, 30000);

  // timed mode countdown (non-blocking)
  if(clsMode.value==='timed120'){
    const endAt = Date.now() + 120000;
    const timer = setInterval(()=>{
      if(state.gameOver){ clearInterval(timer); return; }
      if(Date.now()>=endAt){
        clearInterval(timer);
        gameOver();
      }
    }, 250);
  }
}

function gameOver(){
  if(state.gameOver) return;
  state.gameOver=true; cancelAnimationFrame(loopHandle); clearTimeout(safetyTimerId);
  mustGet('finalScore').textContent=String(state.score);
  mustGet('finalLines').textContent=String(state.lines);
  mustGet('finalLevel').textContent=String(state.level);
  const secs=Math.max(1, Math.round((Date.now()-sessionStart)/1000));
  const lpm=(state.lines/(secs/60)).toFixed(1);
  mustGet('finalLPM').textContent=String(lpm);
  mustGet('finalTSpins').textContent=String(stats.tspins);
  mustGet('finalPCs').textContent=String(stats.perfects);
  gameOverModal.classList.remove('hidden'); pauseBtn.classList.add('hidden'); startBtn.classList.remove('hidden');
  pushClassRow('gameover');
}

function togglePause(){ 
  if(!state.gameStarted||state.gameOver) return; 
  state.paused=!state.paused; 
  if(state.paused){ pauseModal.classList.remove('hidden'); pauseBtn.textContent='RESUME'; pushClassRow('pause'); }
  else { pauseModal.classList.add('hidden'); pauseBtn.textContent='PAUSE'; lastTs=performance.now(); }
}

/* ---------- Keybinds ---------- */
const DEFAULT_KEYS={ left:'ArrowLeft', right:'ArrowRight', down:'ArrowDown', rotate:'ArrowUp', hard:'Enter', hold:'Shift', pause:'p' };
function loadKeys(){ return {...DEFAULT_KEYS, ...safeReadJSON('mc_kb', {})}; }
function saveKeys(map){ store.set('mc_kb',JSON.stringify(map)); }

let KEYS=loadKeys();
const kb = {
  modal: keysModal,
  left: mustGet('kbLeft'),
  right: mustGet('kbRight'),
  down: mustGet('kbDown'),
  rotate: mustGet('kbRotate'),
  hard: mustGet('kbHard'),
  hold: mustGet('kbHold'),
  pause: mustGet('kbPause'),
  save: mustGet('kbSave'),
  cancel: mustGet('kbCancel')
};

function openKeybinds(){ 
  kb.left.value=KEYS.left; kb.right.value=KEYS.right; kb.down.value=KEYS.down; kb.rotate.value=KEYS.rotate; 
  kb.hard.value=KEYS.hard; kb.hold.value=KEYS.hold; kb.pause.value=KEYS.pause; 
  keysModal.classList.remove('hidden'); 
}
kb.save.addEventListener('click',()=>{
  const map={
    left:kb.left.value||DEFAULT_KEYS.left,
    right:kb.right.value||DEFAULT_KEYS.right,
    down:kb.down.value||DEFAULT_KEYS.down,
    rotate:kb.rotate.value||DEFAULT_KEYS.rotate,
    hard:kb.hard.value||DEFAULT_KEYS.hard,
    hold:kb.hold.value||DEFAULT_KEYS.hold,
    pause:kb.pause.value||DEFAULT_KEYS.pause
  };
  KEYS=map; saveKeys(map); keysModal.classList.add('hidden');
});
kb.cancel.addEventListener('click',()=> keysModal.classList.add('hidden'));

/* ---------- Tutorial & drills ---------- */
const tut = {
  modal: tutorialModal,
  body: mustGet('tutBody'),
  next: mustGet('tutNext'),
  prev: mustGet('tutPrev'),
  exit: mustGet('tutExit'),
  step: 0, active:false, practiceMode:false
};

const slides = [
  { title:"Welcome", html:`<p>This tutorial covers controls, the 7-bag randomizer, SRS rotation with wall-kicks, lock delay, ghost piece, and scoring bonuses.</p><p>Use the buttons below to navigate. You can exit anytime.</p>` },
  { title:"Controls", html:`<ul class="tut-list"><li>Move: <b>← →</b>, Soft Drop: <b>↓</b></li><li>Rotate: <b>↑</b> or <b>Space</b>, Hard Drop: <b>Enter</b></li><li>Hold: <b>C</b> or <b>Shift</b>, Pause: <b>P</b></li><li>You can customize keys via <b>KEY BINDS</b>.</li></ul>` },
  { title:"Mechanics", html:`<p><b>7-bag</b> ensures a fair distribution of pieces. <b>Lock delay</b> gives a small window to adjust after landing. <b>SRS</b> allows wall-kicks to complete rotations in tight spaces.</p>` },
  { title:"Scoring", html:`<p>Lines: 1=100, 2=300, 3=500, 4=800 (× level). <b>T-Spin</b> bonus: +${TSPIN_BONUS}. <b>Perfect Clear</b> bonus: +${PERFECT_CLEAR_BONUS}.</p>` },
  { title:"Drill: T-Spin Single", html:`<p>Try a quick T-Spin Single drill.</p><button class="btn btn-primary" onclick="startTSpinDrill()" style="margin-top:.6rem;">START DRILL</button>` },
  { title:"Drill: Perfect Clear", html:`<p>Try a Perfect Clear challenge from a simple setup.</p><button class="btn btn-primary" onclick="startPCDrill()" style="margin-top:.6rem;">START DRILL</button>` },
  { title:"Finish", html:`<p>You’re set. Close the tutorial and hit <b>START</b> when ready.</p>` }
];

function renderSlide(){ 
  const s=slides[tut.step]; 
  tut.body.innerHTML=`<h3 style="margin-bottom:.4rem">${s.title}</h3>${s.html}`; 
  tut.prev.disabled=(tut.step===0); 
  tut.next.textContent=(tut.step===slides.length-1)?'Finish':'Next'; 
}
function openTutorial(){ tut.step=0; tut.active=true; tut.practiceMode=false; renderSlide(); tutorialModal.classList.remove('hidden'); }
function closeTutorial(){ tut.active=false; tut.practiceMode=false; tutorialModal.classList.add('hidden'); if(!state.gameStarted) startModal.classList.remove('hidden'); }
function tutAdvance(){ if(tut.step<slides.length-1){ tut.step++; renderSlide(); } else { closeTutorial(); } }
function tutBack(){ if(tut.step>0){ tut.step--; renderSlide(); } }
tut.next.addEventListener('click', ()=> tutAdvance());
tut.prev.addEventListener('click', ()=> tutBack());
tut.exit.addEventListener('click', ()=> closeTutorial());

/* Drills */
function startTSpinDrill(){
  tut.practiceMode=true; tutorialModal.classList.add('hidden');
  state={ board:[], cur:null, hold:null, score:0, lines:0, level:1, paused:false, gameOver:false, acc:0, downHeld:false, gameStarted:true, adaptive:false, ghost:true, symbolic:false, queueSize:3 };
  makeBoard();
  // T-slot with simple stack (blue J for contrast)
  for(let y=BOARD_HEIGHT-4;y<BOARD_HEIGHT;y++) for(let x=0;x<BOARD_WIDTH;x++){
    const leave=((y===BOARD_HEIGHT-3 && x===4) || (y===BOARD_HEIGHT-2 && (x===3||x===5)) || (y===BOARD_HEIGHT-1 && x===4));
    if(!leave) state.board[y][x]='color-J';
  }
  queue=['T','I','L','S','Z','J','O']; popNext(); state.cur.y=14; state.cur.x=4;
  drawHold(); drawNext(); updateDisplay(); cancelAnimationFrame(loopHandle); lastTs=performance.now(); loopHandle=requestAnimationFrame(loop);
}

function startPCDrill(){
  tut.practiceMode=true; tutorialModal.classList.add('hidden');
  state={ board:[], cur:null, hold:null, score:0, lines:0, level:1, paused:false, gameOver:false, acc:0, downHeld:false, gameStarted:true, adaptive:false, ghost:true, symbolic:false, queueSize:5 };
  makeBoard();
  // Simple near-empty setup; a single line missing cells to encourage a PC
  for(let x=0;x<BOARD_WIDTH;x++){ if(x!==4) state.board[BOARD_HEIGHT-1][x]='color-S'; }
  // piece queue that can complete a PC if used well
  queue=['I','O','T','S','Z','J','L']; popNext(); state.cur.y=15; state.cur.x=3;
  drawHold(); drawNext(); updateDisplay(); cancelAnimationFrame(loopHandle); lastTs=performance.now(); loopHandle=requestAnimationFrame(loop);
}

// Expose drills for inline tutorial buttons
window.startTSpinDrill=startTSpinDrill;
window.startPCDrill=startPCDrill;

/* ---------- Keyboard, focus, touch ---------- */
document.addEventListener('keydown',(e)=>{
  // quick start from start modal / game over
  if(!state.gameStarted || state.gameOver){
    if(e.key===' '||e.key==='Enter'){ e.preventDefault(); startWithSeed(optDaily.checked?'daily':optSeed.value); }
    return;
  }
  const k=e.key;
  if(k===KEYS.left){ e.preventDefault(); if(state.cur){ move(-1,0); markInput(); updateDisplay(); } }
  else if(k===KEYS.right){ e.preventDefault(); if(state.cur){ move(1,0); markInput(); updateDisplay(); } }
  else if(k===KEYS.down){ e.preventDefault(); state.downHeld=true; markInput(); }
  else if(k===KEYS.rotate || k===' '){ e.preventDefault(); rotateCurCW(); markInput(); }
  else if(k===KEYS.hard){ e.preventDefault(); hardDrop(); markInput(); }
  else if(k===KEYS.hold || k==='c' || k==='C' || k==='Shift'){ e.preventDefault(); holdSwap(); markInput(); }
  else if(k.toLowerCase()===KEYS.pause.toLowerCase()){ e.preventDefault(); togglePause(); }
});
document.addEventListener('keyup',(e)=>{ if(e.key===KEYS.down) state.downHeld=false; });
window.addEventListener('blur', ()=>{ state.downHeld=false; }); // safety

// Touch convenience: turn touches into clicks instantly
[...document.querySelectorAll('.btn')].forEach(b=>{
  b.addEventListener('touchend', e=>{ e.preventDefault(); b.click(); }, {passive:false});
});

/* ---------- Init & bindings ---------- */
function initThemeAndSizing(){
  // restore zoom/slow if present
  const z=store.get('mc_zoom', '1'); if(['1','1.25','1.5'].includes(z)) clsZoom.value=z;
  const s=store.get('mc_slow', '1'); if(['1','1.25','1.5','2'].includes(s)) clsSlow.value=s;
  applyZoomSlow();
}

function initialPaint(){
  state={ board:[], cur:null, hold:null, score:0, lines:0, level:1, paused:true, gameOver:false, acc:0, downHeld:false, gameStarted:false, adaptive:true, ghost:true, symbolic:false, queueSize:+optQueue.value||5 };
  makeBoard(); drawHold(); drawNext(); resizeCanvas(); drawBoard(); showBests();
}

document.addEventListener('DOMContentLoaded', ()=>{
  parseAndApplyURL();
  initThemeAndSizing();
  initialPaint();
  updateOrientHint();

  // Start buttons
  startBtn.addEventListener('click', (e)=>{ e.preventDefault(); startWithSeed(optDaily.checked?'daily':optSeed.value); });
  startModalStartBtn.addEventListener('click', (e)=>{ e.preventDefault(); startWithSeed(optDaily.checked?'daily':optSeed.value); });
  gameOverRestartBtn.addEventListener('click', (e)=>{ e.preventDefault(); startWithSeed(optDaily.checked?'daily':optSeed.value); });
  gameOverRetrySeedBtn.addEventListener('click', (e)=>{ e.preventDefault(); retrySameSeed(); });
  btnRetrySeed.addEventListener('click', (e)=>{ e.preventDefault(); retrySameSeed(); });

  // Tutorial open
  startModalTutBtn.addEventListener('click', (e)=>{ e.preventDefault(); openTutorial(); });
  tutorialBtn.addEventListener('click', (e)=>{ e.preventDefault(); openTutorial(); });

  // Other controls
  pauseBtn.addEventListener('click', togglePause);
  rotateBtn.addEventListener('click', ()=> rotateCurCW());
  dropBtn.addEventListener('click', ()=> hardDrop());
  holdBtn.addEventListener('click', ()=> holdSwap());
  exportBtn.addEventListener('click', exportAll);
  exportMineBtn.addEventListener('click', exportMine);

  // Classroom options
  clsZoom.addEventListener('change', applyZoomSlow);
  clsSlow.addEventListener('change', applyZoomSlow);

  // Options live hooks
  optQueue.addEventListener('change', ()=>{ if(state){ state.queueSize=+optQueue.value; drawNext(); } });
  optGhostAlpha.addEventListener('input', ()=>{ ghostAlpha = clamp(parseFloat(optGhostAlpha.value)||0.25, 0.1, 0.6); updateDisplay(); });
  optLock.addEventListener('input', ()=>{ LOCK_DELAY=+optLock.value; });

  // Name persistence UI
  playerName.addEventListener('input', ()=> showBests());

  // Teacher tools
  btnCopyURL.addEventListener('click', ()=>{
    const u=shareableURL();
    navigator.clipboard?.writeText(u).then(()=> alert('Shareable URL copied!')).catch(()=>{ prompt('Copy URL:',u); });
  });
  btnResetLog.addEventListener('click', ()=>{
    if(!confirm('Really clear ALL stored sessions on this browser? This cannot be undone.')) return;
    writeAllRows([]);
    alert('Logs cleared.');
  });

  // Resize/orientation
  window.addEventListener('resize', ()=>{ resizeCanvas(); updateOrientHint(); updateDisplay(); });
});


</script>
  <script>
/* ===========================================================
   MC TETRIS — Classroom Canvas (Silent Edition)
   Part 4 / 4: Final small bindings and close-out
   =========================================================== */

/* In case parts were pasted separately, ensure the "KEY BINDS" button opens the modal */
document.addEventListener('DOMContentLoaded', ()=>{
  try{
    keysBtn?.addEventListener('click', (e)=>{ e.preventDefault(); openKeybinds(); });
  }catch{}
});

/* Optional: prevent window from scrolling on Space/Arrow keys when the game is active */
window.addEventListener('keydown', (e)=>{
  if(state?.gameStarted && !/INPUT|TEXTAREA|SELECT/.test((e.target||{}).tagName||'')){
    // prevent page scroll for game-relevant keys
    if([' ','Spacebar','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)){
      e.preventDefault();
    }
  }
}, {passive:false});
</script>

</body>
</html>



