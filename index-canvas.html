 mc_tetris.html
  <!DOCTYPE html>
  <html lang="en">
  <head>
  <meta charset="utf-8"/>
  <title>MC TETRIS  Classroom Canvas (Silent Edition)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet"/>
  <style>
  :root{
    --ink:#0af7a3; --cyan:#07e1ff; --space:#070a16; --panel:#0b1220;
    --gridline: rgba(26,42,68,.55); --accent:#b6fff1;
  }
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%}
  body{
    font-family:'JetBrains Mono',monospace;
    background:var(--space); color:#e6fff6;
    min-height:100vh; padding:1rem; overflow-x:hidden; position:relative;
  }
  .mc-bg{position:fixed; inset:0; z-index:-2; pointer-events:none; overflow:hidden}
  .mc-art{position:absolute; inset:-2%; background:radial-gradient(120% 120% at 50% 10%, rgba(5,12,22,.92),
  rgba(3,8,16,1)); filter:saturate(1.05) contrast(1.02) brightness(.95); animation:mcDrift 22s ease-in-out infinite}
  @keyframes mcDrift{from{transform:scale(1.02)}to{transform:scale(1.06) translate(-2%,2%)}}
  .mc-aurora{position:absolute; inset:-10%;
    background:radial-gradient(40% 60% at 20% 10%, rgba(122,92,255,.22) 0%, transparent 60%),
               radial-gradient(48% 58% at 80% 0%, rgba(7,225,255,.18) 0%, transparent 60%),
               radial-gradient(46% 62% at 80% 80%, rgba(18,255,176,.18) 0%, transparent 70%);
    filter:blur(28px) saturate(120%); animation:mcAurora 14s ease-in-out infinite alternate
  }
  @keyframes mcAurora{0%{transform:none}100%{transform:translate(-2%,2%) scale(1.04)}}
  .mc-scan{position:absolute; inset:0; background:linear-gradient(transparent 50%, rgba(0,0,0,.18) 50%); background-
  size:100% 3px; opacity:.22}
  .mc-vignette{position:absolute; inset:0; background:radial-gradient(120% 120% at 50% 25%, transparent 55%,
  rgba(0,0,0,.45) 90%); mix-blend-mode:multiply}
  .mc-watermark{position:absolute; right:12px; bottom:10px; user-select:none; font-weight:800; letter-
  spacing:.25rem; font-size:.7rem; color:rgba(18,255,176,.22)}

  .container{max-width:1200px; margin:0 auto; position:relative}
  .title{text-align:center; font-size:2.2rem; font-weight:800; letter-spacing:.3rem; margin-bottom:.6rem;
  color:var(--accent); text-shadow:0 0 12px var(--ink),0 0 26px var(--cyan)}
  .subtitle{text-align:center; font-size:.9rem; opacity:.85; margin-bottom:1rem}

  .game-layout{display:grid; grid-template-columns:1fr minmax(280px,360px) 1fr; gap:1rem; align-items:start}
  .side-panel{
    background:linear-gradient(180deg, rgba(12,18,32,.82), rgba(8,12,24,.82));
    border:2px solid rgba(18,255,176,.5); border-radius:10px; padding:1rem;
    box-shadow:0 0 24px rgba(18,255,176,.25), inset 0 0 28px rgba(0,0,0,.35)
  }
  .panel-title{font-size:1rem; font-weight:800; text-align:center; margin:.3rem 0 .6rem}
  .score-item{display:flex; justify-content:space-between; margin-bottom:.35rem; font-size:.95rem}
  .score-value{color:var(--cyan); font-weight:800}

  .game-board{
    border:4px solid rgba(18,255,176,.65); border-radius:10px;
    background:radial-gradient(120% 120% at 50% 10%, rgba(5,12,22,.92), rgba(3,8,16,1));
    box-shadow:0 0 24px rgba(18,255,176,.25), inset 0 0 28px rgba(0,0,0,.35);
    display:flex; justify-content:center; align-items:center; padding:4px
  }
  #gameCanvas{display:block; image-rendering:pixelated; max-width:100%; height:auto}

  .mini-grid{width:96px; height:96px; border:2px solid #044; border-radius:6px; background:#000; margin:.35rem auto;
    display:grid; grid-template-columns:repeat(4,1fr); grid-template-rows:repeat(4,1fr); gap:1px; padding:3px}
  .preview-cell{background:#000; border-radius:2px}
  .mini-list{display:grid; grid-template-columns:1fr; gap:.35rem; justify-items:center}

  .controls{display:grid; grid-template-columns:1fr 1fr; gap:.5rem}
  .btn{
    background:rgba(10,16,28,.9); border:2px solid rgba(18,255,176,.6); color:#e6fff6;
    padding:.6rem .8rem; border-radius:8px; font-weight:700; cursor:pointer; transition:.15s; text-
  transform:uppercase; touch-action:manipulation
  }
  .btn:hover:not(:disabled){background:rgba(12,20,36,1); border-color:var(--cyan); box-shadow:0 0 12px
  rgba(7,225,255,.35)}
  .btn:disabled{opacity:.55; cursor:not-allowed}
  .btn-primary{background:linear-gradient(180deg,#0a3,#092); color:#fff; grid-column:span 2}
  .btn-wide{grid-column:span 2}
  .hidden{display:none!important}

  .opt{display:grid; grid-template-columns:auto 1fr; gap:.45rem .6rem; align-items:center; font-size:.85rem; margin-
  top:.4rem}
  .opt input[type="number"], .opt select, .opt input[type="text"]{
    background:#0a0a0a; color:#9fffbf; border:1px solid #044; border-radius:6px; padding:.35rem .4rem; width:100%
  }
  .opt input[type="range"]{width:100%}
  .opt .hint{font-size:.75rem; opacity:.75; grid-column:span 2}

  /* Modal */
  .modal{position:fixed; inset:0; background:rgba(0,0,0,.88); display:flex; align-items:center; justify-
  content:center; z-index:1000; padding:1rem}
  .modal-content{background:#111; border:4px solid rgba(18,255,176,.8); border-radius:12px; padding:1.2rem; text-
  align:center; max-width:760px; width:100%; box-shadow:0 0 30px rgba(0,255,176,.4)}
  .modal-title{font-size:2rem; font-weight:900; margin-bottom:.4rem}
  .modal-text{margin-bottom:.8rem; color:#aaf9ff}
  .modal-stats{margin:.6rem 0; display:grid; grid-template-columns:repeat(3,1fr); gap:.6rem}
  .stat-item{background:#000; border:1px solid #044; border-radius:8px; padding:.4rem}
  .stat-value{font-size:1.1rem; font-weight:900; color:var(--cyan)}
  .stat-label{font-size:.75rem; color:#0a0}

  .kbd-grid{display:grid; grid-template-columns:1fr 1fr; gap:.5rem .6rem; margin-top:.4rem; text-align:left}
  .kbd-grid label{font-size:.85rem}
  .kbd-grid input{background:#0a0a0a; color:#9fffbf; border:1px solid #044; border-radius:6px; padding:.35rem .4rem}

  .tut-body{text-align:left; font-size:.95rem; color:#9fffbf}
  .tut-nav{display:flex; justify-content:center; gap:.6rem; margin-top:.6rem}

  /* Colors */
  .color-I{background:#00f0ff!important}
  .color-O{background:#ffd900!important}
  .color-T{background:#9d63ff!important}
  .color-S{background:#15ff76!important}
  .color-Z{background:#ff4b4b!important}
  .color-J{background:#4a74ff!important}
  .color-L{background:#ff9a2b!important}

  /* Teacher overlay */
  .teacher{background:var(--panel); border:2px solid rgba(18,255,176,.5); border-radius:10px; padding:.6rem; margin-
  top:.6rem}
  .teacher h4{margin:.2rem 0 .4rem; font-size:1rem; text-align:center}
  .teacher .row{display:grid; grid-template-columns:1fr 1fr; gap:.35rem}
  .teacher small{opacity:.75}

  /* Orientation hint */
  #orientHint{position:fixed; inset:0; display:none; align-items:center; justify-content:center;
  background:rgba(0,0,0,.9); color:#b6fff1; z-index:2000; text-align:center; padding:1rem}
  #orientHint p{max-width:480px}

  @media (max-width:1024px){
    .game-layout{grid-template-columns:1fr; gap:1rem}
    .title{font-size:2rem; letter-spacing:.2rem}
  }
  </style>
  </head>
  <body>
    <div class="mc-bg" aria-hidden="true">
      <div class="mc-art"></div>
      <div class="mc-aurora"></div>
      <div class="mc-scan"></div>
      <div class="mc-vignette"></div>
      <div class="mc-watermark">MCSTEPHEN</div>
    </div>
    <div class="container" role="application" aria-label="Tetris game">
      <h1 class="title">M C  T E T R I S</h1>
      <p class="subtitle">Silent classroom edition  deterministic seeds  CSV logs  teacher tools</p>

      <div class="game-layout">
        <!-- Left panel -->
        <aside class="side-panel" aria-label="Score and queue">
          <div class="panel-title">PLAYER</div>
          <div class="opt">
            <label for="playerName">Name</label>
            <input id="playerName" type="text" placeholder="e.g., Jordan A." maxlength="40"/>
            <div class="hint">Required for tracking personal bests and exports.</div>
          </div>

          <div class="panel-title" style="margin-top:.6rem;">SCORE</div>
          <div class="score-item"><span>Score</span><span class="score-value" id="score">0</span></div>
          <div class="score-item"><span>Lines</span><span class="score-value" id="lines">0</span></div>
          <div class="score-item"><span>Level</span><span class="score-value" id="level">1</span></div>

          <div class="panel-title" style="margin-top:.6rem;">HOLD</div>
          <div class="mini-grid" id="holdBox" aria-label="Hold preview"></div>

          <div class="panel-title" style="margin-top:.6rem;">NEXT</div>
          <div class="mini-list" id="nextList" aria-label="Next pieces">
            <div class="mini-grid"></div><div class="mini-grid"></div><div class="mini-grid"></div><div class="mini-
  grid"></div><div class="mini-grid"></div>
          </div>
        </aside>

        <!-- Board -->
        <main class="game-board" id="gameBoard">
          <canvas id="gameCanvas" aria-label="Game board" role="img"></canvas>
        </main>

        <!-- Right panel -->
        <aside class="side-panel" aria-label="Controls and options">
          <div class="panel-title">CONTROLS</div>
          <div class="controls" role="group" aria-label="Game controls">
            <button class="btn btn-primary" id="startBtn">START</button>
            <button class="btn hidden" id="pauseBtn">PAUSE</button>
            <button class="btn" id="rotateBtn">ROTATE</button>
            <button class="btn" id="dropBtn">HARD DROP</button>
            <button class="btn" id="holdBtn">HOLD</button>
            <button class="btn" id="keysBtn">KEY BINDS</button>
            <button class="btn" id="tutorialBtn">TUTORIAL</button>
            <button class="btn" id="exportBtn">EXPORT CSV (ALL)</button>
            <button class="btn" id="exportMineBtn">EXPORT MINE</button>
          </div>

          <div class="panel-title" style="margin-top:.6rem;">CLASSROOM MODE</div>
          <div class="opt" role="group" aria-label="Classroom options">
            <label>Mode</label>
            <select id="clsMode">
              <option value="free">Free Play</option>
              <option value="timed120">Timed  2 minutes</option>
              <option value="drill_tspin">Drill  T-Spin Single</option>
              <option value="drill_pc">Drill  Perfect Clear</option>
            </select>

            <label>Lesson Seed</label>
            <select id="clsSeed">
              <option value="daily">Daily</option>
              <option value="123456">#123456</option>
              <option value="8675309">#8675309</option>
              <option value="424242">#424242</option>
              <option value="987654321">#987654321</option>
            </select>

            <label>Projector Mode</label>
            <select id="clsZoom">
              <option value="1">Normal</option>
              <option value="1.25">Large</option>
              <option value="1.5">XL</option>
            </select>

            <label>Slow Motion</label>
            <select id="clsSlow">
              <option value="1">Off</option>
              <option value="1.25">x1.25</option>
              <option value="1.5">x1.5</option>
              <option value="2">x2</option>
            </select>

            <div class="hint">Share URLs carry mode/seed/zoom/slow/name.</div>
          </div>

          <div class="panel-title" style="margin-top:.6rem;">OPTIONS</div>
          <div class="opt">
            <label><input type="checkbox" id="optAdaptive" checked/> Adaptive Mode</label><span></span>
            <label>Lock Delay</label><input type="range" id="optLock" min="200" max="800" value="500"/>
            <label>Daily Seed</label><input type="checkbox" id="optDaily"/>
            <label>Seed</label><input type="number" id="optSeed" value="0" min="0" step="1" inputmode="numeric"/>
            <label>Queue Size</label><select id="optQueue"><option>5</option><option>4</option><option>3</option></
  select>
            <label><input type="checkbox" id="optGhost" checked/> Ghost Piece</label><span></span>
            <label>Ghost Opacity</label><input type="range" id="optGhostAlpha" min="0.1" max="0.6" step="0.05"
  value="0.25"/>
            <label><input type="checkbox" id="optSymbolic"/> Symbolic Score Boost</label><span></span>
          </div>

          <div class="teacher" aria-label="Teacher tools">
            <h4>Teacher Tools</h4>
            <div class="row">
              <button class="btn" id="btnResetLog" title="Clears ALL stored sessions for this browser">Reset Logs</
  button>
              <button class="btn" id="btnCopyURL">Copy Shareable URL</button>
              <button class="btn" id="btnResetBests" title="Clears personal bests for the current name">Reset My
  Bests</button>
              <button class="btn btn-wide" id="btnRetrySeed">Retry Same Seed</button>
            </div>
            <small>Tip: add <code>?mode=free&seed=daily&zoom=1.25&slow=1.5&name=Alex</code> to the URL.</small>
          </div>
        </aside>
      </div>

      <!-- Modals -->
      <div class="modal" id="startModal" aria-modal="true" role="dialog">
        <div class="modal-content">
          <div class="modal-title">T  E  T  R  I  S</div>
          <div class="modal-text">Silent classroom edition â€” smooth loop, deterministic seeds, teaching tools.</div>
          <div id="bestWrap" style="margin:.4rem 0 .2rem; font-size:.9rem; opacity:.85;"></div>
          <div style="display:flex; gap:.6rem; flex-wrap:wrap; justify-content:center;">
            <button class="btn" id="startModalTutBtn" style="min-width:160px;">TUTORIAL</button>
            <button class="btn btn-primary" id="startModalStartBtn" style="min-width:160px;" disabled>START GAME</
  button>
            <button class="btn" id="startModalDemoBtn" style="min-width:160px;">DEMO (NO NAME)</button>
          </div>
          <div style="margin-top:.6rem; font-size:.8rem; opacity:.75;">Press SPACE or ENTER to start</div>
        </div>
      </div>

      <div class="modal hidden" id="gameOverModal" aria-modal="true" role="dialog">
        <div class="modal-content">
          <div class="modal-title">GAME OVER</div>
          <div class="modal-stats">
            <div class="stat-item"><div class="stat-value" id="finalScore">0</div><div class="stat-label">SCORE</
  div></div>
            <div class="stat-item"><div class="stat-value" id="finalLines">0</div><div class="stat-label">LINES</
  div></div>
            <div class="stat-item"><div class="stat-value" id="finalLevel">1</div><div class="stat-label">LEVEL</
  div></div>
            <div class="stat-item"><div class="stat-value" id="finalLPM">0</div><div class="stat-label">LPM</div></
  div>
            <div class="stat-item"><div class="stat-value" id="finalTSpins">0</div><div class="stat-label">T-SPINS</
  div></div>
            <div class="stat-item"><div class="stat-value" id="finalPCs">0</div><div class="stat-label">PERFECT
  CLEARS</div></div>
          </div>
          <div style="display:flex; gap:.6rem; flex-wrap:wrap; justify-content:center;">
            <button class="btn" id="gameOverRestartBtn" style="min-width:160px;">PLAY AGAIN</button>
            <button class="btn btn-primary" id="gameOverRetrySeedBtn" style="min-width:180px;">RETRY SAME SEED</
  button>
          </div>
          <div style="margin-top:.6rem; font-size:.8rem; opacity:.75;">Press SPACE or ENTER to start</div>
        </div>
      </div>

      <div class="modal hidden" id="pauseModal" aria-modal="true" role="dialog">
        <div class="modal-content">
          <div class="modal-title">PAUSED</div>
          <div class="modal-text">Press P or click PAUSE to continue.</div>
        </div>
      </div>

      <div class="modal hidden" id="keysModal" aria-modal="true" role="dialog">
        <div class="modal-content">
          <div class="modal-title">KEY BINDS</div>
          <div class="kbd-grid">
            <label>Left</label><input id="kbLeft"  placeholder="ArrowLeft"/>
            <label>Right</label><input id="kbRight" placeholder="ArrowRight"/>
            <label>Soft Drop</label><input id="kbDown"  placeholder="ArrowDown"/>
            <label>Rotate</label><input id="kbRotate" placeholder="ArrowUp / Space"/>
            <label>Hard Drop</label><input id="kbHard"  placeholder="Enter"/>
            <label>Hold</label><input id="kbHold"  placeholder="C / Shift"/>
            <label>Pause</label><input id="kbPause" placeholder="P"/>
          </div>
          <div style="display:flex; gap:.6rem; justify-content:center; margin-top:.6rem;">
            <button class="btn" id="kbCancel">Cancel</button>
            <button class="btn btn-primary" id="kbSave">Save</button>
          </div>
        </div>
      </div>

      <div class="modal hidden" id="tutorialModal" aria-modal="true" role="dialog">
        <div class="modal-content" style="max-width:720px;">
          <div class="modal-title">TUTORIAL</div>
          <div id="tutBody" class="tut-body"></div>
          <div class="tut-nav">
            <button class="btn" id="tutPrev">Back</button>
            <button class="btn" id="tutExit">Exit</button>
            <button class="btn btn-primary" id="tutNext">Next</button>
          </div>
        </div>
      </div>
    </div>
    <div id="orientHint"><p>For a better classroom experience, rotate your device to <b>landscape</b> or use a wider
  window.</p></div>
  <script>
  "use strict";

  /* ---------- Utilities ---------- */
  function mustGet(id){ const el=document.getElementById(id); if(!el) throw new Error('Missing #' + id); return
  el; }
  const store = {
    get:(k,f='')=>{ try{ return localStorage.getItem(k) ?? f }catch{ return f } },
    set:(k,v)=>{ try{ localStorage.setItem(k,v); return true } catch(e){ console.error('Storage error:',e);
  alert('Local storage is full or unavailable  logs/settings may not be saved.'); return false; } }
  };
  function safeReadJSON(key, fallback){
    try{ const raw=store.get(key, JSON.stringify(fallback)); const parsed=JSON.parse(raw); return
  Array.isArray(parsed)||typeof parsed==='object'?parsed:fallback; }
    catch{ return fallback; }
  }

  /* ---------- Constants ---------- */
  const BOARD_WIDTH=10, BOARD_HEIGHT=20;
  let CSS_CELL=32;
  const INITIAL_SPEED=500; let LOCK_DELAY=500;
  const SOFT_POINT=1, HARD_POINT=2;
  const LINE_SCORE=[0,100,300,500,800], TSPIN_BONUS=400, PERFECT_CLEAR_BONUS=1800;
  const CLASS_KEY='mc_tetris_classlog', BEST_KEY='mc_tetris_best', NAME_KEY='mc_tetris_name';
  const LOG_CAP=500;
  const VALID_MODES=['free','timed120','drill_tspin','drill_pc'];

  /* ---------- Canvas ---------- */
  const canvas=mustGet('gameCanvas'); const ctx=canvas.getContext('2d',{alpha:false});
  let gridLayer=null, gridLayerCtx=null;
  function buildGridLayer(){
    gridLayer=document.createElement('canvas');
    gridLayer.width=BOARD_WIDTH*CSS_CELL; gridLayer.height=BOARD_HEIGHT*CSS_CELL;
    gridLayerCtx=gridLayer.getContext('2d',{alpha:false});
    gridLayerCtx.fillStyle='#000'; gridLayerCtx.fillRect(0,0,gridLayer.width,gridLayer.height);
    gridLayerCtx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--gridline') ||
  'rgba(26,42,68,.55)';
    gridLayerCtx.lineWidth=1;
    for(let x=0;x<=BOARD_WIDTH;x++){ gridLayerCtx.beginPath(); gridLayerCtx.moveTo(x*CSS_CELL,0);
  gridLayerCtx.lineTo(x*CSS_CELL,BOARD_HEIGHT*CSS_CELL); gridLayerCtx.stroke(); }
    for(let y=0;y<=BOARD_HEIGHT;y++){ gridLayerCtx.beginPath(); gridLayerCtx.moveTo(0,y*CSS_CELL);
  gridLayerCtx.lineTo(BOARD_WIDTH*CSS_CELL,y*CSS_CELL); gridLayerCtx.stroke(); }
  }
  function resizeCanvas(){
    const dpr=Math.max(1,Math.floor(window.devicePixelRatio||1));
    const cssW=Math.floor(BOARD_WIDTH*CSS_CELL), cssH=Math.floor(BOARD_HEIGHT*CSS_CELL);
    canvas.style.width=cssW+'px'; canvas.style.height=cssH+'px';
    canvas.width=cssW*dpr; canvas.height=cssH*dpr; ctx.setTransform(dpr,0,0,dpr,0,0);
    buildGridLayer();
  }

  /* ---------- DOM ---------- */
  const orientHint=mustGet('orientHint');
  function updateOrientHint(){ const w=innerWidth,h=innerHeight;
  orientHint.style.display=(w<h&&w<700)?'flex':'none'; }

  const startModal=mustGet('startModal'), gameOverModal=mustGet('gameOverModal'), pauseModal=mustGet('pauseModal');
  const keysModal=mustGet('keysModal'), tutorialModal=mustGet('tutorialModal');

  const startBtn=mustGet('startBtn'), startModalStartBtn=mustGet('startModalStartBtn'),
  startModalDemoBtn=mustGet('startModalDemoBtn'), startModalTutBtn=mustGet('startModalTutBtn');
  const gameOverRestartBtn=mustGet('gameOverRestartBtn'), gameOverRetrySeedBtn=mustGet('gameOverRetrySeedBtn');

  const pauseBtn=mustGet('pauseBtn'), rotateBtn=mustGet('rotateBtn'), dropBtn=mustGet('dropBtn'),
  holdBtn=mustGet('holdBtn');
  const keysBtn=mustGet('keysBtn'), tutorialBtn=mustGet('tutorialBtn');
  const exportBtn=mustGet('exportBtn'), exportMineBtn=mustGet('exportMineBtn');

  const scoreEl=mustGet('score'), linesEl=mustGet('lines'), levelEl=mustGet('level');
  const holdBox=mustGet('holdBox'), nextList=mustGet('nextList');

  const playerName=mustGet('playerName');

  const optAdaptive=mustGet('optAdaptive'), optLock=mustGet('optLock'), optDaily=mustGet('optDaily');
  const optSeed=mustGet('optSeed'), optQueue=mustGet('optQueue'), optGhost=mustGet('optGhost');
  const optGhostAlpha=mustGet('optGhostAlpha'), optSymbolic=mustGet('optSymbolic');

  const clsMode=mustGet('clsMode'), clsSeed=mustGet('clsSeed'), clsZoom=mustGet('clsZoom'),
  clsSlow=mustGet('clsSlow');

  const btnResetLog=mustGet('btnResetLog'), btnCopyURL=mustGet('btnCopyURL'), btnRetrySeed=mustGet('btnRetrySeed'),
  btnResetBests=mustGet('btnResetBests');

  const bestWrap=mustGet('bestWrap');

  /* ---------- Pieces ---------- */
  const COLOR_MAP={'color-I':'#00f0ff','color-O':'#ffd900','color-T':'#9d63ff','color-S':'#15ff76','color-
  Z':'#ff4b4b','color-J':'#4a74ff','color-L':'#ff9a2b'};
  const TETROMINOES={
    I:{shape:[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],class:'color-I',id:1},
    O:{shape:[[1,1],[1,1]],class:'color-O',id:3},
    T:{shape:[[0,1,0],[1,1,1],[0,0,0]],class:'color-T',id:2},
    S:{shape:[[0,1,1],[1,1,0],[0,0,0]],class:'color-S',id:4},
    Z:{shape:[[1,1,0],[0,1,1],[0,0,0]],class:'color-Z',id:5},
    J:{shape:[[1,0,0],[1,1,1],[0,0,0]],class:'color-J',id:6},
    L:{shape:[[0,0,1],[1,1,1],[0,0,0]],class:'color-L',id:7}
  };
  const TYPES=Object.keys(TETROMINOES);

  /* SRS */
  const SRS_JLSTZ={'0>1':[[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],'1>0':[[0,0],[1,0],[1,1],[0,-2],[1,-2]],'1>2':[[0,0],
  [1,0],[1,1],[0,-2],[1,-2]],'2>1':[[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],'2>3':[[0,0],[1,0],[1,-1],[0,2],[1,2]],'3>2':
  [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],'3>0':[[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],'0>3':[[0,0],[1,0],[1,-1],[0,2],
  [1,2]]};
  const SRS_I={'0>1':[[0,0],[-2,0],[1,0],[-2,1],[1,-2]],'1>0':[[0,0],[2,0],[-1,0],[2,-1],[-1,2]],'1>2':[[0,0],
  [-1,0],[2,0],[-1,-2],[2,1]],'2>1':[[0,0],[1,0],[-2,0],[1,2],[-2,-1]],'2>3':[[0,0],[2,0],[-1,0],[2,-1],
  [-1,2]],'3>2':[[0,0],[-2,0],[1,0],[-2,1],[1,-2]],'3>0':[[0,0],[1,0],[-2,0],[1,2],[-2,-1]],'0>3':[[0,0],[-1,0],
  [2,0],[-1,-2],[2,1]]};

  /* ---------- RNG ---------- */
  let rngSeed=(Math.random()*1e9)>>>0;
  function dailySeed(){ const d=new Date(); return (d.getFullYear()*10000+(d.getMonth()+1)*100+d.getDate())>>>0; }
  function xs32(){ rngSeed^=rngSeed<<13; rngSeed^=rngSeed>>>17; rngSeed^=rngSeed<<5; return
  (rngSeed>>>0)/0xffffffff; }
  function newBag(){ const arr=[1,2,3,4,5,6,7]; for(let i=arr.length-1;i>0;i++){ const j=Math.floor(xs32()*(i+1));
  [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr.map(id=>TYPES.find(k=>TETROMINOES[k].id===id)); }

  /* ---------- State ---------- */
  let state={};
  let queue=[], canHold=true, lockSince=null, loopHandle=0;
  let lastActionWasRotate=false, animClearing=false;
  let ghostAlpha=0.25, sessionStart=Date.now();
  const stats={tspins:0,perfects:0};
  const roll={inputs:0,soft:0,hard:0,mis:0,locks:0,rotFail:0,lastInputAt:performance.now(),meanLatency:0};
  let lastTs=performance.now(), lastStartedSeed=null, slowMo=1;

  /* ---------- Helpers ---------- */
  function makeBoard(){ state.board=Array.from({length:BOARD_HEIGHT},()=>Array.from({length:BOARD_WIDTH},
  ()=>null)); }
  function spawnPiece(t){ const d=TETROMINOES[t]; return
  {type:t,class:d.class,o:0,shape:d.shape.map(r=>r.slice()),x:Math.floor(BOARD_WIDTH/2)-Math.floor(d.shape[0].length
  /2),y:-1}; }
  function currentCells(p){ const a=[]; for(let py=0;py<p.shape.length;py++) for(let px=0;px<p.shape[py].length;px+
  +) if(p.shape[py][px]) a.push({x:p.x+px,y:p.y+py}); return a; }
  function validAt(board,p,X,Y,shapeOverride=null){
    const shp=shapeOverride||p.shape;
    for(let py=0;py<shp.length;py++) for(let px=0;px<shp[py].length;px++) if(shp[py][px]){
      const x=X+px, y=Y+py;
      if(x<0||x>=BOARD_WIDTH||y>=BOARD_HEIGHT) return false;
      if(y>=0 && board[y][x]) return false;
    }
    return true;
  }
  function rotCW(shape){ const r=shape.length,c=shape[0].length,out=Array.from({length:c},()=>Array(r).fill(0));
  for(let i=0;i<r;i++) for(let j=0;j<c;j++) out[j][r-1-i]=shape[i][j]; return out; }
  function srsRotateCW(p){
    const from=p.o,to=(p.o+1)&3, cand=rotCW(p.shape);
    if(p.type==='O'){ if(validAt(state.board,p,p.x,p.y,cand)) return {ok:true,x:p.x,y:p.y,shape:cand,o:to}; return
  {ok:false}; }
    const table=(p.type==='I')?SRS_I:SRS_JLSTZ, kicks=table[`${from}>${to}`];
    for(const [dx,dy] of kicks){ const nx=p.x+dx, ny=p.y+dy; if(validAt(state.board,p,nx,ny,cand)) return
  {ok:true,x:nx,y:ny,shape:cand,o:to}; }
    return {ok:false};
  }
  function ghostY(board,p){ let y=p.y; while(validAt(board,p,p.x,y+1)) y++; return y; }

  /* ---------- UI mini previews ---------- */
  function miniGrid(el,shape,cls){
    el.innerHTML='';
    for(let y=0;y<4;y++) for(let x=0;x<4;x++){
      const c=document.createElement('div'); c.className='preview-cell';
      if(shape?.[y]?.[x]) c.classList.add(cls); el.appendChild(c);
    }
  }
  function drawHold(){ const h=state.hold?TETROMINOES[state.hold.type]:null; const sh=h?h.shape:[[0,0,0,0],
  [0,0,0,0],[0,0,0,0],[0,0,0,0]]; miniGrid(holdBox,sh,h?h.class:''); }
  function drawNext(){
    const minis=[...nextList.querySelectorAll('.mini-grid')];
    minis.forEach((m,i)=>{ m.style.display=(i<(state.queueSize||5))?'':'none'; });
    for(let i=0;i<minis.length;i++){
      const t=queue[i], d=t?TETROMINOES[t]:null, blank=[[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]];
      miniGrid(minis[i], d?d.shape:blank, d?d.class:'');
    }
  }

  /* ---------- Rendering ---------- */
  function drawCell(x,y,cls,alpha=1){
    const color=COLOR_MAP[cls]||'#fff'; const px=x*CSS_CELL, py=y*CSS_CELL;
    ctx.globalAlpha=alpha; ctx.fillStyle=color; ctx.fillRect(px+1,py+1,CSS_CELL-2,CSS_CELL-2);
    ctx.fillStyle='rgba(255,255,255,0.28)'; ctx.fillRect(px+1,py+1,CSS_CELL-2,Math.floor(CSS_CELL/3));
    ctx.fillStyle='rgba(0,0,0,0.22)'; ctx.fillRect(px+1,py+CSS_CELL-Math.floor(CSS_CELL/3),CSS_CELL-
  2,Math.floor(CSS_CELL/3));
    ctx.globalAlpha=1;
  }
  function drawBoard(){
    ctx.drawImage(gridLayer,0,0);
    for(let y=0;y<BOARD_HEIGHT;y++) for(let x=0;x<BOARD_WIDTH;x++) if(state.board[y][x]) drawCell(x,y,state.board[y]
  [x]);
    if(state.ghost && state.cur && !animClearing){
      const gy=ghostY(state.board,state.cur);
      for(const {x,y} of currentCells({...state.cur,y:gy})){ if(y>=0) drawCell(x,y,state.cur.class,ghostAlpha); }
    }
    if(state.cur){ for(const {x,y} of currentCells(state.cur)){ if(y>=0) drawCell(x,y,state.cur.class); } }
    if(lockSince!==null && state.cur){
      const pulse=Math.sin((performance.now()-lockSince)/100)*0.2+0.8;
      ctx.globalAlpha=pulse;
      for(const {x,y} of currentCells(state.cur)){ if(y>=0){ ctx.fillStyle='rgba(255,255,255,0.3)';
  ctx.fillRect(x*CSS_CELL,y*CSS_CELL,CSS_CELL,CSS_CELL); } }
      ctx.globalAlpha=1;
    }
  }
  function updateDisplay(){ drawBoard(); scoreEl.textContent=String(state.score);
  linesEl.textContent=String(state.lines); levelEl.textContent=String(state.level); }

  /* ---------- Queue & moves ---------- */
  function popNext(){ while(queue.length<7) queue=queue.concat(newBag()); const type=queue.shift();
  state.cur=spawnPiece(type); lastActionWasRotate=false; lockSince=null; drawNext(); }
  function ensureSpawnValid(){ if(!validAt(state.board,state.cur,state.cur.x,state.cur.y)){ gameOver(); return
  false; } return true; }
  function holdSwap(){
    if(!canHold||!state.cur) return; const curType=state.cur.type;
    if(!state.hold){ state.hold={type:curType}; popNext(); }
    else { const swap=state.hold.type; state.hold={type:curType}; state.cur=spawnPiece(swap); }
    canHold=false; lastActionWasRotate=false; lockSince=null; drawHold(); if(!ensureSpawnValid()) return;
  }
  function move(dx,dy){
    if(!state.cur) return false; const nx=state.cur.x+dx, ny=state.cur.y+dy;
    if(validAt(state.board,state.cur,nx,ny)){ state.cur.x=nx; state.cur.y=ny; if(dy>0) lastActionWasRotate=false;
  return true; }
    if(dx!==0) roll.mis++; return false;
  }
  function filledRows(){ const rows=[]; for(let y=0;y<BOARD_HEIGHT;y++) if(state.board[y].every(Boolean))
  rows.push(y); return rows; }

  /* ---------- T-Spin ---------- */
  function isTSpin(){
    if(!lastActionWasRotate || state.cur?.type!=='T') return false;
    const c={x:state.cur.x+1,y:state.cur.y+1};
    const corners=[{x:c.x-1,y:c.y-1},{x:c.x+1,y:c.y-1},{x:c.x-1,y:c.y+1},{x:c.x+1,y:c.y+1}];
    const filled=corners.filter(({x,y})=> x<0||x>=BOARD_WIDTH||y<0||y>=BOARD_HEIGHT||state.board[y]?.[x]).length;
    return filled>=3;
  }

  /* ---------- Line clear ---------- */
  function animateClearAndApply(rows, onDone){
    animClearing=true; let flashCount=0; const maxFlashes=6;
    const iv=setInterval(()=>{
      flashCount++;
      for(const y of rows) for(let x=0;x<BOARD_WIDTH;x++){
        ctx.fillStyle=(flashCount%2===0)?'#9dff9d':'#ffffff';
        ctx.fillRect(x*CSS_CELL+1,y*CSS_CELL+1,CSS_CELL-2,CSS_CELL-2);
      }
      if(flashCount>=maxFlashes){
        clearInterval(iv);
        const sorted=rows.slice().sort((a,b)=>b-a);
        for(const y of sorted){ state.board.splice(y,1); state.board.unshift(Array(BOARD_WIDTH).fill(null)); }
        animClearing=false; onDone && onDone();
      }
    }, 70);
  }

  /* ---------- Lock & scoring ---------- */
  function lockPiece(){
    const p=state.cur;
    for(let py=0;py<p.shape.length;py++) for(let px=0;px<p.shape[py].length;px++) if(p.shape[py][px]){ const
  x=p.x+px, y=p.y+py; if(y>=0) state.board[y][x]=p.class; }
    roll.locks++; lockSince=null;

    const rows=filledRows(); const tspin=isTSpin(); const hadBlocks=state.board.some(r=>r.some(Boolean));

    if(rows.length>0){
      animateClearAndApply(rows, ()=>{
        let gained=LINE_SCORE[rows.length]*Math.max(1,state.level);
        if(tspin){ gained+=TSPIN_BONUS; stats.tspins++; }
        if(!state.board.some(r=>r.some(Boolean)) && hadBlocks){ gained+=PERFECT_CLEAR_BONUS; stats.perfects++; }
        if(state.symbolic){ const misRate=roll.mis/Math.max(1,roll.locks); const mult=Math.max(1,1+0.15*(1-
  Math.min(1,misRate))); gained=Math.round(gained*mult); }
        state.score+=gained; state.lines+=rows.length; state.level=Math.floor(state.lines/10)+1;

        if(clsMode.value==='drill_tspin' && tspin){ drillSuccess('T-Spin completed!'); }
        if(clsMode.value==='drill_pc' && !state.board.some(r=>r.some(Boolean))){ drillSuccess('Perfect Clear!'); }

        popNext(); canHold=true; if(!ensureSpawnValid()) return; updateDisplay();
      });
    } else {
      popNext(); canHold=true; if(!ensureSpawnValid()) return; updateDisplay();
    }
  }

  /* ---------- Drops & rotation ---------- */
  function hardDrop(){ let dist=0; while(move(0,1)) dist++; if(dist>0){ state.score+=dist*HARD_POINT; roll.hard+
  +; } lockPiece(); }
  function rotateCurCW(){
    if(!state.cur) return; const r=srsRotateCW(state.cur);
    if(r.ok){ state.cur.shape=r.shape; state.cur.x=r.x; state.cur.y=r.y; state.cur.o=r.o; lastActionWasRotate=true;
  lockSince=null; markInput(); }
    else { roll.rotFail++; }
  }

  /* ---------- Gravity & adaptive ---------- */
  function gravityInterval(){ return Math.max(50, (INITIAL_SPEED - (state.level-1)*50) * slowMo); }
  let adaptClock=0;
  function adaptTick(dt){
    if(!state.adaptive||state.gameOver||state.paused) return;
    adaptClock+=dt; if(adaptClock<12000) return; adaptClock=0;
    const age=(Date.now()-sessionStart)/1000, lpm=state.lines/Math.max(1,age/60);
    const misRate=roll.mis/Math.max(1,roll.locks), latency=roll.meanLatency||120;
    const comfort=(lpm/1.5)+(1-Math.min(1,misRate))+(120/Math.max(60,latency));
    if(comfort>=2){ LOCK_DELAY=Math.max(200,LOCK_DELAY-40); state.queueSize=Math.max(3,state.queueSize-1); }
    else { LOCK_DELAY=Math.min(800,LOCK_DELAY+40); state.ghost=true;
  state.queueSize=Math.min(5,Math.max(3,state.queueSize)); }
    optLock.value=String(LOCK_DELAY); drawNext();
  }

  /* ---------- Main loop ---------- */
  function loop(ts){
    const dt=ts-lastTs; lastTs=ts;
    if(!state.paused && !state.gameOver && !animClearing){
      state.acc+=dt; const g=gravityInterval();
      while(state.acc>=g){
        state.acc-=g;
        if(!move(0,1)){ const now=performance.now(); if(lockSince===null) lockSince=now; if(now-
  lockSince>=LOCK_DELAY) lockPiece(); break; }
      }
      if(state.downHeld && move(0,1)){ state.score+=SOFT_POINT; roll.soft++; }
      adaptTick(dt); updateDisplay();
    }
    loopHandle=requestAnimationFrame(loop);
  }

  /* ---------- Metrics & CSV ---------- */
  function markInput(){ const now=performance.now(), dt=now-roll.lastInputAt; roll.lastInputAt=now; roll.inputs++;
  roll.meanLatency=roll.meanLatency===0?dt:0.9*roll.meanLatency+0.1*dt; }
  function readAllRows(){ return safeReadJSON(CLASS_KEY, []); }
  function writeAllRows(arr){ while(arr.length>LOG_CAP) arr.shift(); const ok=store.set(CLASS_KEY,
  JSON.stringify(arr)); if(!ok) console.warn('Failed to save logs (quota?)'); return ok; }
  function escCSV(s){ const t=String(s??''); return /[",\n]/.test(t)?`"${t.replace(/"/g,'""')}"`:t; }
  function pushClassRow(status){
    const dur=Math.round((Date.now()-sessionStart)/1000);
    const row={ ts:new Date().toISOString(), name:(playerName.value||'').slice(0,40), status, mode:clsMode.value,
  seed:lastStartedSeed ?? rngSeed,
      score:state.score, lines:state.lines, level:state.level, dur_s:dur, inputs:roll.inputs,
  latency_ms:Math.round(roll.meanLatency),
      soft:roll.soft, hard:roll.hard, mis:roll.mis, rotFail:roll.rotFail, locks:roll.locks, tspins:stats.tspins,
  perfects:stats.perfects };
    const arr=readAllRows(); arr.push(row);
    if(!writeAllRows(arr)){ alert('Logs not saved (browser storage full). Consider exporting & resetting logs.'); }
    updateBest(row);
  }
  function exportCSV(rows){
    const
  cols=['ts','name','status','mode','seed','score','lines','level','dur_s','inputs','latency_ms','soft','hard','mis'
  ,'rotFail','locks','tspins','perfects'];
    const head=cols.join(','), body=rows.map(r=>cols.map(k=>escCSV(r?.[k]??'')).join(',')).join('\n');
    const blob=new Blob([head+'\n'+body],{type:'text/csv'}); const url=URL.createObjectURL(blob); const
  a=document.createElement('a');
    a.href=url; a.download='mc_tetris_classlog.csv'; a.click(); URL.revokeObjectURL(url);
  }
  function exportAll(){ const rows=readAllRows(); if(rows.length===0){ alert('No session data to export yet.');
  return; } exportCSV(rows); }
  function exportMine(){
    const name=(playerName.value||'').slice(0,40); if(!name){ alert('Enter your name first to export your
  sessions.'); return; }
    const rows=readAllRows().filter(r=>(r.name||'').toLowerCase()===name.toLowerCase()); if(rows.length===0)
  { alert('No sessions found for this name on this browser.'); return; }
    exportCSV(rows);
  }

  /* ---------- Bests ---------- */
  function readBest(){ return safeReadJSON(BEST_KEY, {}); }
  function writeBest(b){ const ok=store.set(BEST_KEY, JSON.stringify(b)); if(!ok) console.warn('Failed to save
  bests'); return ok; }
  function bestKey(name,mode){ return `${(name||'').trim().toLowerCase()}::${mode}`; }
  function updateBest(row){
    const name=(row.name||'').trim(); if(!name) return;
    const key=bestKey(name,row.mode); const all=readBest(); const prev=all[key];
    if(!prev || row.score>prev.score){ all[key]={score:row.score, lines:row.lines, level:row.level, ts:row.ts,
  mode:row.mode}; writeBest(all); }
  }
  function getModeLabel(m){ switch(m){ case 'free': return 'Free Play'; case 'timed120': return 'Timed (2m)'; case
  'drill_tspin': return 'Drill: T-Spin'; case 'drill_pc': return 'Drill: Perfect Clear'; default: return m; } }
  function showBests(){
    const all=readBest(); const name=(playerName.value||'').trim().toLowerCase(); const
  modes=['free','timed120','drill_tspin','drill_pc'];
    const rows=modes.map(m=>{ const bk=bestKey(name,m), b=all[bk];
      return b ? `<li><b>${getModeLabel(m)}</b>  <b>${b.score}</b> pts  ${b.lines} lines  L${b.level} <span
  style="opacity:.7">(${new Date(b.ts).toLocaleString()})</span></li>`
               : `<li><b>${getModeLabel(m)}</b>  <span style="opacity:.7">no record yet</span></li>`; }).join('');
    bestWrap.innerHTML = name ? `<div><b>${playerName.value}</b>  Personal Bests</div><ul style="text-
  align:left;margin:.3rem 0 0 1rem">${rows}</ul>`
                              : `<div style="opacity:.8">Enter your name to track progress.</div>`;
  }
  function resetMyBests(){
    const nm=(playerName.value||'').trim().toLowerCase(); if(!nm){ alert('Enter your name first.'); return; }
    const all=readBest(); let count=0;
    for(const k of Object.keys(all)){ if(k.startsWith(nm+'::')){ delete all[k]; count++; } }
    writeBest(all); showBests(); alert(count>0 ? 'Personal bests cleared for '+playerName.value : 'No personal bests
  stored for this name.');
  }

  /* ---------- URL & Share ---------- */
  function parseAndApplyURL(){
    const p=new URLSearchParams(location.search);
    if(p.has('name')) playerName.value = p.get('name').slice(0,40);
    if(p.has('mode')){ const m=p.get('mode'); if(VALID_MODES.includes(m)) clsMode.value=m; }
    if(p.has('seed')){ const s=p.get('seed'); if(s==='daily'){ clsSeed.value='daily'; optDaily.checked=true; } else
  if(/^\d{1,10}$/.test(s)){ clsSeed.value=s; optDaily.checked=false; optSeed.value=String(+s); } }
    if(p.has('zoom')){ const z=p.get('zoom'); if(['1','1.25','1.5'].includes(z)) clsZoom.value=z; }
    if(p.has('slow')){ const sl=p.get('slow'); if(['1','1.25','1.5','2'].includes(sl)) clsSlow.value=sl; }
  }
  function shareableURL(){
    const url=new URL(location.href), params=url.searchParams; const name=(playerName.value||'').slice(0,40);
    if(name) params.set('name',name); else params.delete('name');
    params.set('mode', clsMode.value); params.set('seed', optDaily.checked ? 'daily' : String(+optSeed.value||0));
    params.set('zoom', clsZoom.value); params.set('slow', clsSlow.value); url.search=params.toString(); return
  url.toString();
  }

  /* ---------- Lifecycle ---------- */
  function resetAnalytics(){ stats.tspins=0; stats.perfects=0;
  roll.inputs=roll.soft=roll.hard=roll.mis=roll.locks=roll.rotFail=0; roll.meanLatency=0;
  roll.lastInputAt=performance.now(); }
  function startWithSeed(seed){
    if(seed==='daily'){ rngSeed=dailySeed(); optDaily.checked=true; }
    else { const n=(+seed)||Math.floor(Math.random()*1e9); rngSeed=(n>>>0); optDaily.checked=false;
  optSeed.value=String(n); }
    lastStartedSeed=rngSeed; startGame();
  }
  function retrySameSeed(){ if(lastStartedSeed==null){ alert('No seed in memory yet. Start a game first.');
  return; } startWithSeed(lastStartedSeed); }
  function applyZoomSlow(){ const z=parseFloat(clsZoom.value)||1, s=parseFloat(clsSlow.value)||1; slowMo=s;
  CSS_CELL=Math.round(32*z); resizeCanvas(); updateDisplay(); store.set('mc_zoom', String(z)); store.set('mc_slow',
  String(s)); }

  /* Gate start: require name or allow demo */
  function canTrackName(){ return !!(playerName.value||'').trim(); }
  function updateStartEnabled(){ startModalStartBtn.disabled = !canTrackName(); }

  function startGame(){
    LOCK_DELAY=+optLock.value;
    const adaptive=optAdaptive.checked, ghost=optGhost.checked, symbolic=optSymbolic.checked, qsize=+optQueue.value;
    const clsSel=clsSeed.value;
    if(clsSel==='daily'){ rngSeed=dailySeed(); optDaily.checked=true; }
    else if(/^\d+$/.test(clsSel)){ rngSeed=(+clsSel)>>>0; optDaily.checked=false; optSeed.value=String(rngSeed); }
    else { rngSeed = optDaily.checked ? dailySeed() : ((+optSeed.value)||Math.floor(Math.random()*1e9))>>>0; }
    lastStartedSeed=rngSeed;

    state={ board:[], cur:null, hold:null, score:0, lines:0, level:1, paused:false, gameOver:false,
            acc:0, downHeld:false, gameStarted:true, adaptive, ghost, symbolic, queueSize:qsize };

    sessionStart=Date.now(); resetAnalytics(); lastActionWasRotate=false; animClearing=false;

    makeBoard(); queue=newBag(); popNext(); drawHold(); drawNext(); if(!ensureSpawnValid()) return; updateDisplay();

    startModal.classList.add('hidden'); gameOverModal.classList.add('hidden');
    startBtn.classList.add('hidden'); pauseBtn.classList.remove('hidden');

    cancelAnimationFrame(loopHandle); lastTs=performance.now(); loopHandle=requestAnimationFrame(loop);

    if(clsMode.value==='timed120'){
      const endAt=Date.now()+120000;
      const timer=setInterval(()=>{ if(state.gameOver){ clearInterval(timer); return; } if(Date.now()>=endAt)
  { clearInterval(timer); gameOver(); } }, 250);
    }
  }
  function gameOver(){
    if(state.gameOver) return;
    state.gameOver=true; cancelAnimationFrame(loopHandle);
    mustGet('finalScore').textContent=String(state.score);
    mustGet('finalLines').textContent=String(state.lines);
    mustGet('finalLevel').textContent=String(state.level);
    const secs=Math.max(1, Math.round((Date.now()-sessionStart)/1000));
    const lpm=(state.lines/(secs/60)).toFixed(1);
    mustGet('finalLPM').textContent=String(lpm);
    mustGet('finalTSpins').textContent=String(stats.tspins);
    mustGet('finalPCs').textContent=String(stats.perfects);
    gameOverModal.classList.remove('hidden'); pauseBtn.classList.add('hidden'); startBtn.classList.remove('hidden');
    pushClassRow('gameover');
  }
  function togglePause(){
    if(!state.gameStarted||state.gameOver) return;
    state.paused=!state.paused;
    if(state.paused){ pauseModal.classList.remove('hidden'); pauseBtn.textContent='RESUME'; pushClassRow('pause'); }
    else { pauseModal.classList.add('hidden'); pauseBtn.textContent='PAUSE'; lastTs=performance.now(); }
  }

  /* ---------- Tutorial ---------- */
  const tut={ pages:[
      {title:'Welcome to MC Tetris', body:'<p>This is a <b>deterministic Tetris</b> designed for classroom
  learning.</p><p>Use your keyboard or buttons to play.</p>'},
      {title:'Controls', body:'<p><b>Arrow Keys</b> move</p><p><b>Arrow Down</b> soft drop</p><p><b>Arrow Up /
  Space</b> rotate</p><p><b>Enter</b> hard drop</p><p><b>Shift / C</b> hold</p><p><b>P</b> pause</p>'},
      {title:'Game Modes', body:'<p><b>Free Play</b>  Play indefinitely</p><p><b>Timed</b>  2-minute challenge</
  p><p><b>Drills</b>  Practice specific moves</p>'},
      {title:'Scoring', body:'<p>Lines scale with level.</p><p><b>T-Spins</b> and <b>Perfect Clears</b> give
  bonuses.</p>'},
      {title:'Good Luck!', body:'<p>Use seeds to replay the same game.</p><p>Track progress with personal bests.</
  p>'}
    ],
    currentPage:0,
    show(){ this.currentPage=0; this.render(); tutorialModal.classList.remove('hidden'); },
    render(){ const p=this.pages[this.currentPage];
  mustGet('tutBody').innerHTML=p.body; mustGet('tutPrev').disabled=this.currentPage===0;
  mustGet('tutNext').disabled=this.currentPage===this.pages.length-1; },
    next(){ if(this.currentPage<this.pages.length-1){ this.currentPage++; this.render(); } },
    prev(){ if(this.currentPage>0){ this.currentPage--; this.render(); } },
    exit(){ tutorialModal.classList.add('hidden'); }
  };

  /* ---------- Keybinds ---------- */
  const
  DEFAULT_KEYS={left:'ArrowLeft',right:'ArrowRight',down:'ArrowDown',rotate:'ArrowUp',hard:'Enter',hold:'Shift',paus
  e:'p'};
  function loadKeys(){ return {...DEFAULT_KEYS, ...safeReadJSON('mc_kb', {})}; }
  function saveKeys(map){ store.set('mc_kb', JSON.stringify(map)); }
  let KEYS=loadKeys();
  const kb={ modal:keysModal, left:mustGet('kbLeft'), right:mustGet('kbRight'), down:mustGet('kbDown'),
  rotate:mustGet('kbRotate'), hard:mustGet('kbHard'), hold:mustGet('kbHold'), pause:mustGet('kbPause'),
  save:mustGet('kbSave'), cancel:mustGet('kbCancel') };
  function openKeybinds(){ kb.left.value=KEYS.left; kb.right.value=KEYS.right; kb.down.value=KEYS.down;
  kb.rotate.value=KEYS.rotate; kb.hard.value=KEYS.hard; kb.hold.value=KEYS.hold; kb.pause.value=KEYS.pause;
  keysModal.classList.remove('hidden'); }
  kb.save.addEventListener('click',()=>{ const map={ left:kb.left.value||DEFAULT_KEYS.left, right:kb.right.value||
  DEFAULT_KEYS.right, down:kb.down.value||DEFAULT_KEYS.down, rotate:kb.rotate.value||DEFAULT_KEYS.rotate,
  hard:kb.hard.value||DEFAULT_KEYS.hard, hold:kb.hold.value||DEFAULT_KEYS.hold, pause:kb.pause.value||
  DEFAULT_KEYS.pause }; KEYS=map; saveKeys(map); keysModal.classList.add('hidden'); });
  kb.cancel.addEventListener('click',()=>{ keysModal.classList.add('hidden'); });

  /* ---------- Keyboard ---------- */
  document.addEventListener('keydown',(e)=>{
    const tag=(document.activeElement && document.activeElement.tagName||'').toLowerCase();
    let handled=false;

    if(!state.gameStarted && !startModal.classList.contains('hidden') && (e.key===' '||e.key==='Enter') && tag!
  =='input' && tag!=='textarea'){
      if(canTrackName()){ startGame(); } else { alert('Enter your name to track bests, or click DEMO to start
  without tracking.'); }
      handled=true;
    }

    if(state.gameStarted){
      const k=e.key.toLowerCase();
      if(k===KEYS.left.toLowerCase()){ move(-1,0); markInput(); handled=true; }
      else if(k===KEYS.right.toLowerCase()){ move(1,0); markInput(); handled=true; }
      else if(k===KEYS.down.toLowerCase()){ state.downHeld=true; handled=true; }
      else if(k===KEYS.rotate.toLowerCase() || e.key===' '){ rotateCurCW(); markInput(); handled=true; }
      else if(k===KEYS.hard.toLowerCase()){ hardDrop(); markInput(); handled=true; }
      else if(k===KEYS.hold.toLowerCase()){ holdSwap(); markInput(); handled=true; }
      else if(k===KEYS.pause.toLowerCase()){ togglePause(); handled=true; }
    }
    if(handled) e.preventDefault();
  });
  document.addEventListener('keyup',(e)=>{ if(e.key.toLowerCase()===KEYS.down.toLowerCase())
  state.downHeld=false; });
  window.addEventListener('blur',()=>{ state.downHeld=false; });

  /* ---------- Buttons ---------- */
  startBtn.addEventListener('click',()=>{ showBests(); updateStartEnabled();
  startModal.classList.remove('hidden'); });
  startModalStartBtn.addEventListener('click',()=>{ startGame(); });
  startModalDemoBtn.addEventListener('click',()=>{ startGame(); }); // no name tracking
  startModalTutBtn.addEventListener('click',()=>{ tut.show(); });

  pauseBtn.addEventListener('click',()=>{ togglePause(); });
  rotateBtn.addEventListener('click',()=>{ rotateCurCW(); markInput(); });
  dropBtn.addEventListener('click',()=>{ hardDrop(); markInput(); });
  holdBtn.addEventListener('click',()=>{ holdSwap(); markInput(); });
  keysBtn.addEventListener('click',()=>{ openKeybinds(); });
  tutorialBtn.addEventListener('click',()=>{ tut.show(); });

  exportBtn.addEventListener('click',()=>{ exportAll(); });
  exportMineBtn.addEventListener('click',()=>{ exportMine(); });

  gameOverRestartBtn.addEventListener('click',()=>{ startGame(); });
  gameOverRetrySeedBtn.addEventListener('click',()=>{ retrySameSeed(); });

  btnResetLog.addEventListener('click',()=>{ if(confirm('Clear ALL session logs for this browser? This cannot be
  undone.')){ store.set(CLASS_KEY, JSON.stringify([])); alert('Logs cleared.'); }});
  btnCopyURL.addEventListener('click',()=>{ const url=shareableURL();
  navigator.clipboard.writeText(url).then(()=>alert('Shareable URL copied!')).catch(()=>alert('URL: '+url)); });
  btnRetrySeed.addEventListener('click',()=>{ retrySameSeed(); });
  btnResetBests.addEventListener('click',()=>{ if(confirm('Reset personal bests for this name?'))
  resetMyBests(); });

  /* ---------- Options ---------- */
  optGhostAlpha.addEventListener('input',(e)=>{ ghostAlpha=parseFloat(e.target.value); });
  clsZoom.addEventListener('change',()=>{ applyZoomSlow(); });
  clsSlow.addEventListener('change',()=>{ applyZoomSlow(); });

  /* ---------- Name persistence + live bests ---------- */
  playerName.addEventListener('input', ()=>{
    const nm=(playerName.value||'').slice(0,40);
    store.set(NAME_KEY, nm);
    showBests();
    updateStartEnabled();
  });

  /* ---------- Init ---------- */
  window.addEventListener('resize',()=>{ updateOrientHint(); resizeCanvas(); });
  window.addEventListener('load',()=>{
    resizeCanvas(); updateOrientHint();

    const savedName=store.get(NAME_KEY,''); if(savedName) playerName.value=savedName;
    const savedZoom=store.get('mc_zoom',''); const savedSlow=store.get('mc_slow','');
    if(savedZoom) clsZoom.value=savedZoom; if(savedSlow) clsSlow.value=savedSlow;

    applyZoomSlow(); parseAndApplyURL(); showBests(); updateStartEnabled();
    console.log('MC Tetris ready. Click Start or press Space/Enter.');
  });
  </script>
  </body>
  </html>
