<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>MC TETRIS — Classroom Canvas</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet"/>

  <style>
    :root{
      --bg-url: none;
      --ink:#0af7a3;
      --cyan:#07e1ff;
      --space:#070a16;
      --panel:#0b1220;
      --gridline: rgba(26,42,68,.55);
      --boardShadow: 0 0 24px rgba(18,255,176,.25), inset 0 0 28px rgba(0,0,0,.35);
      --cell: #000;
      --accent:#b6fff1;
    }
    *{box-sizing:border-box; margin:0; padding:0}
    html,body{height:100%}
    body{
      font-family:'JetBrains Mono','Courier Prime',monospace;
      background: var(--space);
      color:#b6fff1;
      min-height:100vh; padding:1rem; overflow-x:hidden; position:relative;
    }
    .mc-bg{ position:fixed; inset:0; z-index:-2; pointer-events:none; overflow:hidden; }
    .mc-art{
      position:absolute; inset:-2%;
      background:
        var(--bg-url),
        radial-gradient(120% 120% at 50% 10%, rgba(5,12,22,.9), rgba(3,8,16,1));
      background-size: cover; background-position: center;
      filter: saturate(1.05) contrast(1.02) brightness(.95);
      animation:mcDrift 22s ease-in-out infinite alternate;
    }
    @keyframes mcDrift{ from{transform:scale(1.02)} to{transform:scale(1.06) translate(-2%,2%)} }
    .mc-aurora{
      position:absolute; inset:-10%;
      background:
        radial-gradient(40% 60% at 20% 10%, rgba(122,92,255,.22) 0%, transparent 60%),
        radial-gradient(48% 58% at 80% 0%, rgba(7,225,255,.18) 0%, transparent 60%),
        radial-gradient(46% 62% at 80% 80%, rgba(18,255,176,.18) 0%, transparent 70%);
      filter: blur(28px) saturate(120%);
      animation:mcAurora 14s ease-in-out infinite alternate;
    }
    @keyframes mcAurora{ 0%{transform:none} 100%{transform:translate(-2%,2%) scale(1.04)} }
    .mc-scan{ position:absolute; inset:0; background: linear-gradient(transparent 50%, rgba(0,0,0,.18) 50%); background-size:100% 3px; opacity:.22; }
    .mc-vignette{ position:absolute; inset:0; background: radial-gradient(120% 120% at 50% 25%, transparent 55%, rgba(0,0,0,.45) 90%); mix-blend-mode:multiply; }
    .mc-watermark{ position:absolute; right:12px; bottom:10px; user-select:none; font-weight:800; letter-spacing:.25rem; font-size:.7rem; color:rgba(18,255,176,.22); }

    .container{max-width:1200px;margin:0 auto;position:relative;}
    .title{ text-align:center; font-size:2.4rem; font-weight:800; letter-spacing:.35rem; margin-bottom:.8rem; color:var(--accent); text-shadow:0 0 12px var(--ink), 0 0 26px var(--cyan);}
    .subtitle{ text-align:center; font-size:.9rem; opacity:.8; margin-bottom:1.2rem;}

    .game-layout{ display:grid; grid-template-columns:1fr minmax(280px,360px) 1fr; gap:1rem; align-items:start; }
    .side-panel{
      background: linear-gradient(180deg, rgba(12,18,32,.82), rgba(8,12,24,.82));
      border:2px solid rgba(18,255,176,.5); border-radius:10px; padding:1rem;
      box-shadow: var(--boardShadow);
    }
    .panel-title{ font-size:1rem; font-weight:800; text-align:center; margin:.3rem 0 .6rem; }
    .score-item{ display:flex; justify-content:space-between; margin-bottom:.4rem; font-size:.95rem; }
    .score-value{ color: var(--cyan); font-weight:800; }

    .game-board{ border:4px solid rgba(18,255,176,.65); border-radius:10px; background: radial-gradient(120% 120% at 50% 10%, rgba(5,12,22,.92), rgba(3,8,16,1)); box-shadow: var(--boardShadow); display:flex; justify-content:center; align-items:center; padding:4px;}
    #gameCanvas{ display:block; image-rendering: pixelated; max-width:100%; height:auto; }

    .mini-grid{ width:96px; height:96px; border:2px solid #044; border-radius:6px; background:#000; margin:.35rem auto;
      display:grid; grid-template-columns:repeat(4,1fr); grid-template-rows:repeat(4,1fr); gap:1px; padding:3px; }
    .preview-cell{ background:#000; border-radius:2px; }
    .mini-list{ display:grid; grid-template-columns:1fr; gap:.35rem; justify-items:center; }

    .controls{ display:grid; grid-template-columns:1fr 1fr; gap:.5rem; }
    .btn{
      background: rgba(10,16,28,.9);
      border:2px solid rgba(18,255,176,.6);
      color: #e6fff6;
      padding:.6rem .8rem; border-radius:8px; font-weight:700; cursor:pointer; transition:.15s; text-transform:uppercase; touch-action:manipulation;
    }
    .btn:hover:not(:disabled){ background: rgba(12,20,36,1); border-color: var(--cyan); box-shadow: 0 0 12px rgba(7,225,255,.35); }
    .btn:disabled{ opacity:.55; cursor:not-allowed; }
    .btn-primary{ background: linear-gradient(180deg,#0a3,#092); color:#fff; grid-column: span 2; }
    .btn-wide{ grid-column: span 2; }
    .hidden{ display:none !important; }

    .opt{ display:grid; grid-template-columns:auto 1fr; gap:.45rem .6rem; align-items:center; font-size:.85rem; margin-top:.4rem; }
    .opt input[type="number"], .opt select{
      background:#0a0a0a; color:#9fffbf; border:1px solid #044; border-radius:6px; padding:.35rem .4rem; width:100%;
    }
    .opt input[type="range"]{ width:100%; }
    .opt .hint{ font-size:.75rem; opacity:.75; grid-column:span 2; }

    /* Modal */
    .modal{ position:fixed; inset:0; background:rgba(0,0,0,.88); display:flex; align-items:center; justify-content:center; z-index:1000; padding:1rem; }
    .modal-content{ background:#111; border:4px solid rgba(18,255,176,.8); border-radius:12px; padding:1.2rem; text-align:center; max-width:760px; width:100%; box-shadow:0 0 30px rgba(0,255,176,.4); }
    .modal-title{ font-size:2rem; font-weight:900; margin-bottom:.4rem; }
    .modal-text{ margin-bottom:.8rem; color:#aaf9ff; }
    .modal-stats{ margin:.6rem 0; display:grid; grid-template-columns:repeat(3,1fr); gap:.6rem; }
    .stat-item{ background:#000; border:1px solid #044; border-radius:8px; padding:.4rem; }
    .stat-value{ font-size:1.1rem; font-weight:900; color:var(--cyan); }
    .stat-label{ font-size:.75rem; color:#0a0; }

    .kbd-grid{display:grid; grid-template-columns:1fr 1fr; gap:.5rem .6rem; margin-top:.4rem; text-align:left}
    .kbd-grid label{font-size:.85rem}
    .kbd-grid input{background:#0a0a0a; color:#9fffbf; border:1px solid #044; border-radius:6px; padding:.35rem .4rem}

    .tut-body{ text-align:left; font-size:.95rem; color:#9fffbf; }
    .tut-body .tut-list{ margin-left:1rem; margin-top:.35rem; list-style:disc; }
    .tut-nav{ display:flex; justify-content:center; gap:.6rem; margin-top:.6rem; }

    /* Colors */
    .color-I{ background:#00f0ff !important; }
    .color-O{ background:#ffd900 !important; }
    .color-T{ background:#9d63ff !important; }
    .color-S{ background:#15ff76 !important; }
    .color-Z{ background:#ff4b4b !important; }
    .color-J{ background:#4a74ff !important; }
    .color-L{ background:#ff9a2b !important; }

    /* Teacher overlay (projector mode) */
    .teacher{ background: var(--panel); border:2px solid rgba(18,255,176,.5); border-radius:10px; padding:.6rem; margin-top:.6rem;}
    .teacher h4{ margin:.2rem 0 .4rem; font-size:1rem; text-align:center; }
    .teacher .row{ display:grid; grid-template-columns:1fr 1fr; gap:.35rem; }
    .teacher small{ opacity:.75 }

    @media (max-width:1024px){
      .game-layout{ grid-template-columns:1fr; gap:1rem; }
      .title{ font-size:2rem; letter-spacing:.2rem; }
    }
  </style>
</head>

<body>
  <div class="mc-bg" aria-hidden="true">
    <div class="mc-art"></div>
    <div class="mc-aurora"></div>
    <div class="mc-scan"></div>
    <div class="mc-vignette"></div>
    <div class="mc-watermark">MCSTEPHEN</div>
  </div>

  <div class="container" role="application" aria-label="Tetris game">
    <h1 class="title">M C  T E T R I S</h1>
    <p class="subtitle">Canvas Edition • classroom tools built-in • deterministic seeds • CSV logs</p>

    <div class="game-layout">
      <!-- Left panel -->
      <aside class="side-panel" aria-label="Score and queue">
        <div class="panel-title">SCORE</div>
        <div class="score-item"><span>Score</span><span class="score-value" id="score">0</span></div>
        <div class="score-item"><span>Lines</span><span class="score-value" id="lines">0</span></div>
        <div class="score-item"><span>Level</span><span class="score-value" id="level">1</span></div>

        <div class="panel-title" style="margin-top:.6rem;">HOLD</div>
        <div class="mini-grid" id="holdBox" aria-label="Hold preview"></div>

        <div class="panel-title" style="margin-top:.6rem;">NEXT</div>
        <div class="mini-list" id="nextList" aria-label="Next pieces">
          <div class="mini-grid"></div>
          <div class="mini-grid"></div>
          <div class="mini-grid"></div>
          <div class="mini-grid"></div>
          <div class="mini-grid"></div>
        </div>
      </aside>

      <!-- Board -->
      <main class="game-board" id="gameBoard">
        <canvas id="gameCanvas" aria-label="Game board" role="img"></canvas>
      </main>

      <!-- Right panel (controls + classroom) -->
      <aside class="side-panel" aria-label="Controls and options">
        <div class="panel-title">CONTROLS</div>
        <div class="controls" role="group" aria-label="Game controls">
          <button class="btn btn-primary" id="startBtn">START</button>
          <button class="btn hidden" id="pauseBtn">PAUSE</button>
          <button class="btn" id="rotateBtn">ROTATE</button>
          <button class="btn" id="dropBtn">HARD DROP</button>
          <button class="btn" id="holdBtn">HOLD</button>
          <button class="btn" id="keysBtn">KEY BINDS</button>
          <button class="btn" id="tutorialBtn">TUTORIAL</button>
          <button class="btn" id="exportBtn">EXPORT CSV</button>
        </div>

        <div class="panel-title" style="margin-top:.6rem;">CLASSROOM MODE</div>
        <div class="opt" role="group" aria-label="Classroom options">
          <label>Mode</label>
          <select id="clsMode">
            <option value="free">Free Play</option>
            <option value="timed120">Timed — 2 minutes</option>
            <option value="drill_tspin">Drill — T-Spin Single</option>
            <option value="drill_pc">Drill — Perfect Clear</option>
          </select>

          <label>Lesson Seed</label>
          <select id="clsSeed">
            <option value="daily">Daily</option>
            <option value="123456">#123456</option>
            <option value="8675309">#8675309</option>
            <option value="424242">#424242</option>
            <option value="987654321">#987654321</option>
          </select>

          <label>Projector Mode</label>
          <select id="clsZoom">
            <option value="1">Normal</option>
            <option value="1.25">Large</option>
            <option value="1.5">XL</option>
          </select>

          <label>Slow Motion</label>
          <select id="clsSlow">
            <option value="1">Off</option>
            <option value="1.25">x1.25</option>
            <option value="1.5">x1.5</option>
            <option value="2">x2</option>
          </select>

          <div class="hint">Tip: choose a seed + mode, then START. All sessions log to CSV.</div>
        </div>

        <div class="panel-title" style="margin-top:.6rem;">OPTIONS</div>
        <div class="opt">
          <label><input type="checkbox" id="optAdaptive" checked/> Adaptive Mode</label><span></span>
          <label>Lock Delay</label><input type="range" id="optLock" min="200" max="800" value="500" />
          <label>Daily Seed</label><input type="checkbox" id="optDaily"/>
          <label>Seed</label><input type="number" id="optSeed" value="0" min="0" step="1" inputmode="numeric" />
          <label>Queue Size</label>
          <select id="optQueue"><option>5</option><option>4</option><option>3</option></select>
          <label><input type="checkbox" id="optGhost" checked/> Ghost Piece</label><span></span>
          <label><input type="checkbox" id="optSymbolic"/> Symbolic Score Boost</label><span></span>
          <label><input type="checkbox" id="optMusic"/> Music</label><span></span>
        </div>

        <div class="teacher" aria-label="Teacher tools">
          <h4>Teacher Tools</h4>
          <div class="row">
            <button class="btn" id="btnBell">Audio Ping</button>
            <button class="btn" id="btnResetLog">Reset Logs</button>
            <button class="btn btn-wide" id="btnCopyURL">Copy Shareable URL</button>
          </div>
          <small>URL carries mode/seed/zoom/slow for students.</small>
        </div>
      </aside>
    </div>

    <!-- Modals -->
    <div class="modal" id="startModal" aria-modal="true" role="dialog">
      <div class="modal-content">
        <div class="modal-title">T  E  T  R  I  S</div>
        <div class="modal-text">Canvas Edition — smooth loop, safe audio, classroom presets.</div>
        <div style="display:flex; gap:.6rem; flex-wrap:wrap; justify-content:center;">
          <button class="btn" id="startModalTutBtn" style="min-width:160px;">TUTORIAL</button>
          <button class="btn btn-primary" id="startModalStartBtn" style="min-width:160px;">START GAME</button>
        </div>
        <div style="margin-top:.6rem; font-size:.8rem; opacity:.75;">Press SPACE or ENTER to start</div>
      </div>
    </div>

    <div class="modal hidden" id="gameOverModal" aria-modal="true" role="dialog">
      <div class="modal-content">
        <div class="modal-title">GAME OVER</div>
        <div class="modal-stats">
          <div class="stat-item"><div class="stat-value" id="finalScore">0</div><div class="stat-label">SCORE</div></div>
          <div class="stat-item"><div class="stat-value" id="finalLines">0</div><div class="stat-label">LINES</div></div>
          <div class="stat-item"><div class="stat-value" id="finalLevel">1</div><div class="stat-label">LEVEL</div></div>
          <div class="stat-item"><div class="stat-value" id="finalLPM">0</div><div class="stat-label">LPM</div></div>
          <div class="stat-item"><div class="stat-value" id="finalTSpins">0</div><div class="stat-label">T-SPINS</div></div>
          <div class="stat-item"><div class="stat-value" id="finalPCs">0</div><div class="stat-label">PERFECT CLEARS</div></div>
        </div>
        <button class="btn btn-primary" id="gameOverRestartBtn" style="width:100%;">PLAY AGAIN</button>
        <div style="margin-top:.6rem; font-size:.8rem; opacity:.75;">Press SPACE or ENTER to start</div>
      </div>
    </div>

    <div class="modal hidden" id="pauseModal" aria-modal="true" role="dialog">
      <div class="modal-content">
        <div class="modal-title">PAUSED</div>
        <div class="modal-text">Press P or click PAUSE to continue.</div>
      </div>
    </div>

    <div class="modal hidden" id="keysModal" aria-modal="true" role="dialog">
      <div class="modal-content">
        <div class="modal-title">KEY BINDS</div>
        <div class="kbd-grid">
          <label>Left</label><input id="kbLeft"  placeholder="ArrowLeft"/>
          <label>Right</label><input id="kbRight" placeholder="ArrowRight"/>
          <label>Soft Drop</label><input id="kbDown"  placeholder="ArrowDown"/>
          <label>Rotate</label><input id="kbRotate" placeholder="ArrowUp / Space"/>
          <label>Hard Drop</label><input id="kbHard"  placeholder="Enter"/>
          <label>Hold</label><input id="kbHold"  placeholder="C / Shift"/>
          <label>Pause</label><input id="kbPause" placeholder="P"/>
        </div>
        <div style="display:flex; gap:.6rem; justify-content:center; margin-top:.6rem;">
          <button class="btn" id="kbCancel">Cancel</button>
          <button class="btn btn-primary" id="kbSave">Save</button>
        </div>
      </div>
    </div>

    <div class="modal hidden" id="tutorialModal" aria-modal="true" role="dialog">
      <div class="modal-content" style="max-width:720px;">
        <div class="modal-title">TUTORIAL</div>
        <div id="tutBody" class="tut-body"></div>
        <div class="tut-nav">
          <button class="btn" id="tutPrev">Back</button>
          <button class="btn" id="tutExit">Exit</button>
          <button class="btn btn-primary" id="tutNext">Next</button>
        </div>
      </div>
    </div>
  </div>

<script>
/* ===========================================================
   MC TETRIS — Classroom Canvas (fixed, race-safe, teachable)
   =========================================================== */

/* ---------- Assets (local playlist, no external audio) ---------- */
const MUSIC_TRACKS = [
  "assets/audio/pixel-dreams-259187.mp3",
  "assets/audio/pixel-fantasia-355123.mp3",
  "assets/audio/pixel-paradise-358340.mp3",
  "assets/audio/pixel-bubbles-287284.mp3",
  "assets/audio/pixel-adventure-382649.mp3",
  "assets/audio/pixel-245147.mp3",
  "assets/audio/game-296273.mp3",
  "assets/audio/chiptune-hibride-407598.mp3",
  "assets/audio/crush-boost-372070.mp3",
  "assets/audio/de-pixel-estoy-hecho-290547.mp3"
];

/* ---------- Canvas (DPR aware) ---------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
let CSS_CELL = 32; // projector zoom will multiply this

const BOARD_WIDTH = 10;
const BOARD_HEIGHT = 20;

function resizeCanvas() {
  const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const cssW = Math.floor(BOARD_WIDTH * CSS_CELL);
  const cssH = Math.floor(BOARD_HEIGHT * CSS_CELL);
  canvas.style.width = cssW + 'px';
  canvas.style.height = cssH + 'px';
  canvas.width = cssW * dpr;
  canvas.height = cssH * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener('resize', resizeCanvas);

/* ---------- Utilities ---------- */
function mustGet(id){ const el=document.getElementById(id); if(!el) throw new Error('Missing #' + id); return el; }
const store={ get:(k,f="{}")=>{ try{ return localStorage.getItem(k) ?? f }catch{ return f } }, set:(k,v)=>{ try{ localStorage.setItem(k,v); return true }catch{ return false } } };
const debounce=(fn,ms=150)=>{ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); } };

/* ---------- Colors ---------- */
const COLOR_MAP = {
  'color-I': '#00f0ff',
  'color-O': '#ffd900',
  'color-T': '#9d63ff',
  'color-S': '#15ff76',
  'color-Z': '#ff4b4b',
  'color-J': '#4a74ff',
  'color-L': '#ff9a2b'
};

/* ---------- Tetrominoes & SRS ---------- */
const TETROMINOES={
  I:{shape:[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],class:'color-I',id:1},
  O:{shape:[[1,1],[1,1]],class:'color-O',id:3},
  T:{shape:[[0,1,0],[1,1,1],[0,0,0]],class:'color-T',id:2},
  S:{shape:[[0,1,1],[1,1,0],[0,0,0]],class:'color-S',id:4},
  Z:{shape:[[1,1,0],[0,1,1],[0,0,0]],class:'color-Z',id:5},
  J:{shape:[[1,0,0],[1,1,1],[0,0,0]],class:'color-J',id:6},
  L:{shape:[[0,0,1],[1,1,1],[0,0,0]],class:'color-L',id:7}
};
const TYPES=Object.keys(TETROMINOES);
const SRS_JLSTZ = {
  '0>1': [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
  '1>0': [[0,0],[1,0],[1,1],[0,-2],[1,-2]],
  '1>2': [[0,0],[1,0],[1,1],[0,-2],[1,-2]],
  '2>1': [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
  '2>3': [[0,0],[1,0],[1,-1],[0,2],[1,2]],
  '3>2': [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
  '3>0': [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
  '0>3': [[0,0],[1,0],[1,-1],[0,2],[1,2]]
};
const SRS_I = {
  '0>1': [[0,0],[-2,0],[1,0],[-2,1],[1,-2]],
  '1>0': [[0,0],[2,0],[-1,0],[2,-1],[-1,2]],
  '1>2': [[0,0],[-1,0],[2,0],[-1,-2],[2,1]],
  '2>1': [[0,0],[1,0],[-2,0],[1,2],[-2,-1]],
  '2>3': [[0,0],[2,0],[-1,0],[2,-1],[-1,2]],
  '3>2': [[0,0],[-2,0],[1,0],[-2,1],[1,-2]],
  '3>0': [[0,0],[1,0],[-2,0],[1,2],[-2,-1]],
  '0>3': [[0,0],[-1,0],[2,0],[-1,-2],[2,1]]
};

/* ---------- DOM refs ---------- */
const startModal=mustGet('startModal');
const gameOverModal=mustGet('gameOverModal');
const pauseModal=mustGet('pauseModal');
const keysModal=mustGet('keysModal');
const tutorialModal=mustGet('tutorialModal');

const startBtn=mustGet('startBtn');
const startModalStartBtn=mustGet('startModalStartBtn');
const startModalTutBtn=mustGet('startModalTutBtn');
const gameOverRestartBtn=mustGet('gameOverRestartBtn');

const pauseBtn=mustGet('pauseBtn');
const rotateBtn=mustGet('rotateBtn');
const dropBtn=mustGet('dropBtn');
const holdBtn=mustGet('holdBtn');
const keysBtn=mustGet('keysBtn');
const tutorialBtn=mustGet('tutorialBtn');
const exportBtn=mustGet('exportBtn');

const scoreEl=mustGet('score');
const linesEl=mustGet('lines');
const levelEl=mustGet('level');
const holdBox=mustGet('holdBox');
const nextList=mustGet('nextList');

const optAdaptive=mustGet('optAdaptive');
const optLock=mustGet('optLock');
const optDaily=mustGet('optDaily');
const optSeed=mustGet('optSeed');
const optQueue=mustGet('optQueue');
const optGhost=mustGet('optGhost');
const optSymbolic=mustGet('optSymbolic');
const optMusic=mustGet('optMusic');

const clsMode=mustGet('clsMode');
const clsSeed=mustGet('clsSeed');
const clsZoom=mustGet('clsZoom');
const clsSlow=mustGet('clsSlow');

const btnBell=mustGet('btnBell');
const btnResetLog=mustGet('btnResetLog');
const btnCopyURL=mustGet('btnCopyURL');

/* ---------- Audio (beep + music with fade & autoplay-safe) ---------- */
let AC=null;
function ac(){ if(!AC){ const C=window.AudioContext||window.webkitAudioContext; if(C) AC=new C(); } return AC; }
function beep(freq=440, dur=0.06, gain=0.03){
  try{
    const c=ac(); if(!c) return;
    const t=c.currentTime;
    const o=c.createOscillator(), g=c.createGain();
    o.type='square'; o.frequency.setValueAtTime(freq,t);
    g.gain.setValueAtTime(0,t);
    g.gain.linearRampToValueAtTime(gain, t+0.005);
    g.gain.linearRampToValueAtTime(0, t+dur);
    o.connect(g); g.connect(c.destination);
    o.start(t); o.stop(t+dur+0.02);
  }catch{}
}
const SND={
  rotate:()=>beep(740,0.05,0.025), move:()=>beep(520,0.03,0.02), drop:()=>beep(960,0.05,0.03),
  line:()=>beep(420,0.06,0.035), tspin:()=>beep(300,0.12,0.05), pc:()=>beep(220,0.18,0.06), over:()=>beep(160,0.25,0.06)
};
let music=null, musicIdx=0;
function stopMusic(){ if(music){ music.pause(); music=null; } }
function playMusicForLevel(level){
  if(!optMusic.checked) return;
  try{
    stopMusic();
    music = new Audio(MUSIC_TRACKS[(level-1)%MUSIC_TRACKS.length]);
    music.loop=true; music.volume=0.28;
    // fade in
    music.addEventListener('play',()=>{
      try{
        music.volume=0;
        const step=()=>{ if(!music) return;
          music.volume=Math.min(0.28, music.volume+0.04);
          if(music.volume<0.28) requestAnimationFrame(step);
        }; step();
      }catch{}
    });
    music.play().catch(()=>{ /* user gesture required; handled by Start button */ });
  }catch{}
}

/* ---------- RNG & Seeds ---------- */
let rngSeed=(Math.random()*1e9)>>>0;
function dailySeed(){ const d=new Date(); return (d.getFullYear()*10000+(d.getMonth()+1)*100+d.getDate())>>>0; }
function xs32(){ rngSeed^=rngSeed<<13; rngSeed^=rngSeed>>>17; rngSeed^=rngSeed<<5; return (rngSeed>>>0)/0xffffffff; }
function newBag(){ const arr=[1,2,3,4,5,6,7]; for(let i=arr.length-1;i>0;i++){ const j=Math.floor(xs32()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr.map(id=>TYPES.find(k=>TETROMINOES[k].id===id)); }

/* ---------- Game State ---------- */
const INITIAL_SPEED=500; // ms/step at level 1
let LOCK_DELAY=500;

const SOFT_POINT=1, HARD_POINT=2;
const LINE_SCORE=[0,100,300,500,800];
const TSPIN_BONUS=400;
const PERFECT_CLEAR_BONUS=1800;

let state={};
let queue=[], canHold=true, lockSince=null, loopHandle=0;
let lastActionWasRotate=false;
let animClearing=false;
let safetyTimerId=null;

let sessionStart=Date.now();
const stats={ tspins:0, perfects:0 };
const roll={ inputs:0, soft:0, hard:0, mis:0, locks:0, lastInputAt:performance.now(), meanLatency:0 };

const CLASS_KEY='mc_tetris_classlog';

/* ---------- Board Helpers ---------- */
function makeBoard(){ state.board=Array.from({length:BOARD_HEIGHT},()=>Array.from({length:BOARD_WIDTH},()=>null)); }
function spawnPiece(t){ const d=TETROMINOES[t]; return {type:t,class:d.class,o:0,shape:d.shape.map(r=>r.slice()),x:Math.floor(BOARD_WIDTH/2)-Math.floor(d.shape[0].length/2),y:-1}; }
function currentCells(p){ const a=[]; for(let py=0;py<p.shape.length;py++) for(let px=0;px<p.shape[py].length;px++) if(p.shape[py][px]) a.push({x:p.x+px,y:p.y+py}); return a; }
function validAt(board,p,X,Y,shapeOverride=null){
  const shp=shapeOverride||p.shape;
  for(let py=0;py<shp.length;py++) for(let px=0;px<shp[py].length;px++) if(shp[py][px]){
    const x=X+px, y=Y+py;
    if(x<0||x>=BOARD_WIDTH||y>=BOARD_HEIGHT) return false;
    if(y>=0 && board[y][x]) return false;
  }
  return true;
}
function rotCW(shape){ const r=shape.length,c=shape[0].length,out=Array.from({length:c},()=>Array(r).fill(0)); for(let i=0;i<r;i++) for(let j=0;j<c;j++) out[j][r-1-i]=shape[i][j]; return out; }
function srsRotateCW(p){
  const from=p.o,to=(p.o+1)&3, cand=rotCW(p.shape);
  if(p.type==='O'){ if(validAt(state.board,p,p.x,p.y,cand)) return {ok:true,x:p.x,y:p.y,shape:cand,o:to}; return {ok:false}; }
  const table=(p.type==='I')?SRS_I:SRS_JLSTZ, kicks=table[`${from}>${to}`];
  for(const [dx,dy] of kicks){ const nx=p.x+dx, ny=p.y+dy; if(validAt(state.board,p,nx,ny,cand)) return {ok:true,x:nx,y:ny,shape:cand,o:to}; }
  return {ok:false};
}
function ghostY(board,p){ let y=p.y; while(validAt(board,p,p.x,y+1)) y++; return y; }

/* ---------- UI Mini Previews ---------- */
function miniGrid(el,shape,cls){ el.innerHTML=''; for(let y=0;y<4;y++) for(let x=0;x<4;x++){ const c=document.createElement('div'); c.className='preview-cell'; if(shape?.[y]?.[x]) c.classList.add(cls); el.appendChild(c);} }
function drawHold(){ const h=state.hold?TETROMINOES[state.hold.type]:null; const sh=h?h.shape:[[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]]; miniGrid(holdBox,sh,h?h.class:''); }
function drawNext(){
  const minis=[...nextList.querySelectorAll('.mini-grid')];
  minis.forEach((m,i)=>{ m.style.display=(i<(state.queueSize||5))?'':'none'; });
  for(let i=0;i<minis.length;i++){
    const t=queue[i], d=t?TETROMINOES[t]:null, blank=[[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]];
    miniGrid(minis[i], d?d.shape:blank, d?d.class:'');
  }
}

/* ---------- Rendering ---------- */
function drawCell(x,y,cls,alpha=1){
  const color = COLOR_MAP[cls] || '#fff';
  const px=x*CSS_CELL, py=y*CSS_CELL;
  ctx.globalAlpha=alpha;
  ctx.fillStyle=color;
  ctx.fillRect(px+1,py+1,CSS_CELL-2,CSS_CELL-2);
  ctx.fillStyle='rgba(255,255,255,0.28)';
  ctx.fillRect(px+1,py+1,CSS_CELL-2,Math.floor(CSS_CELL/3));
  ctx.fillStyle='rgba(0,0,0,0.22)';
  ctx.fillRect(px+1,py+CSS_CELL-Math.floor(CSS_CELL/3),CSS_CELL-2,Math.floor(CSS_CELL/3));
  ctx.globalAlpha=1;
}
function drawBoard(){
  ctx.fillStyle='#000';
  ctx.fillRect(0,0,BOARD_WIDTH*CSS_CELL,BOARD_HEIGHT*CSS_CELL);
  ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--gridline') || 'rgba(26,42,68,.55)';
  ctx.lineWidth=1;
  for(let x=0;x<=BOARD_WIDTH;x++){ ctx.beginPath(); ctx.moveTo(x*CSS_CELL,0); ctx.lineTo(x*CSS_CELL,BOARD_HEIGHT*CSS_CELL); ctx.stroke(); }
  for(let y=0;y<=BOARD_HEIGHT;y++){ ctx.beginPath(); ctx.moveTo(0,y*CSS_CELL); ctx.lineTo(BOARD_WIDTH*CSS_CELL,y*CSS_CELL); ctx.stroke(); }
  for(let y=0;y<BOARD_HEIGHT;y++) for(let x=0;x<BOARD_WIDTH;x++) if(state.board[y][x]) drawCell(x,y,state.board[y][x]);
  if(state.ghost && state.cur && !animClearing){
    const gy=ghostY(state.board,state.cur);
    for(const {x,y} of currentCells({...state.cur,y:gy})){ if(y>=0) drawCell(x,y,state.cur.class,0.25); }
  }
  if(state.cur){ for(const {x,y} of currentCells(state.cur)){ if(y>=0) drawCell(x,y,state.cur.class); } }
  if(lockSince!==null && state.cur){
    const pulse=Math.sin((performance.now()-lockSince)/100)*0.2+0.8;
    ctx.globalAlpha=pulse;
    for(const {x,y} of currentCells(state.cur)){ if(y>=0){ ctx.fillStyle='rgba(255,255,255,0.3)'; ctx.fillRect(x*CSS_CELL,y*CSS_CELL,CSS_CELL,CSS_CELL); } }
    ctx.globalAlpha=1;
  }
}
function updateDisplay(){ drawBoard(); scoreEl.textContent=String(state.score); linesEl.textContent=String(state.lines); levelEl.textContent=String(state.level); }

/* ---------- Queue & Moves ---------- */
function popNext(){ while(queue.length<7) queue=queue.concat(newBag()); const type=queue.shift(); state.cur=spawnPiece(type); lastActionWasRotate=false; lockSince=null; drawNext(); }
function ensureSpawnValid(){ if(!validAt(state.board,state.cur,state.cur.x,state.cur.y)){ gameOver(); return false; } return true; }
function holdSwap(){ if(!canHold||!state.cur) return; const curType=state.cur.type; if(!state.hold){ state.hold={type:curType}; popNext(); } else { const swap=state.hold.type; state.hold={type:curType}; state.cur=spawnPiece(swap); } canHold=false; lastActionWasRotate=false; lockSince=null; drawHold(); if(!ensureSpawnValid()) return; updateDisplay(); }
function move(dx,dy){
  if(!state.cur) return false;
  const nx=state.cur.x+dx, ny=state.cur.y+dy;
  if(validAt(state.board,state.cur,nx,ny)){
    state.cur.x=nx; state.cur.y=ny;
    if(dx!==0) SND.move(); if(dy>0) lastActionWasRotate=false;
    return true;
  }
  if(dx!==0) roll.mis++;
  return false;
}
function filledRows(){ const rows=[]; for(let y=0;y<BOARD_HEIGHT;y++) if(state.board[y].every(Boolean)) rows.push(y); return rows; }

function isTSpin(){ 
  if(!lastActionWasRotate || state.cur?.type!=='T') return false; 
  const c={x:state.cur.x+1,y:state.cur.y+1};
  const corners=[{x:c.x-1,y:c.y-1},{x:c.x+1,y:c.y-1},{x:c.x-1,y:c.y+1},{x:c.x+1,y:c.y+1}];
  const filled=corners.filter(({x,y})=> x<0||x>=BOARD_WIDTH||y<0||y>=BOARD_HEIGHT||state.board[y]?.[x]).length; 
  return filled>=3; 
}

/* ---------- Race-safe row clear ---------- */
function animateClearAndApply(rows, onDone){
  animClearing=true;
  let flashCount=0; const maxFlashes=6;
  const iv=setInterval(()=>{
    flashCount++;
    for(const y of rows){
      for(let x=0;x<BOARD_WIDTH;x++){
        ctx.fillStyle = (flashCount % 2 === 0) ? '#9dff9d' : '#ffffff';
        ctx.fillRect(x * CSS_CELL + 1, y * CSS_CELL + 1, CSS_CELL - 2, CSS_CELL - 2);
      }
    }
    if(flashCount>=maxFlashes){
      clearInterval(iv);
      const sorted=rows.slice().sort((a,b)=>b-a);
      for(const y of sorted){
        state.board.splice(y,1);
        state.board.unshift(Array(BOARD_WIDTH).fill(null));
      }
      animClearing=false;
      onDone && onDone();
    }
  }, 70);
}

/* ---------- Lock & Scoring ---------- */
function lockPiece(){
  const p=state.cur;
  for(let py=0;py<p.shape.length;py++) for(let px=0;px<p.shape[py].length;px++) if(p.shape[py][px]){ const x=p.x+px, y=p.y+py; if(y>=0) state.board[y][x]=p.class; }
  roll.locks++; lockSince=null;

  const rows=filledRows(); 
  const tspin=isTSpin(); 
  const hadBlocks=state.board.some(r=>r.some(Boolean));

  if(rows.length>0){
    if(tspin) SND.tspin(); else SND.line();
    animateClearAndApply(rows, ()=>{
      const oldLevel=state.level;
      let gained=LINE_SCORE[rows.length]*Math.max(1,state.level);
      if(tspin){ gained+=TSPIN_BONUS; stats.tspins++; }
      if(!state.board.some(r=>r.some(Boolean))&&hadBlocks){ gained+=PERFECT_CLEAR_BONUS; stats.perfects++; SND.pc(); }
      if(state.symbolic){ const misRate=roll.mis/Math.max(1,roll.locks); const mult=Math.max(1,1+0.15*(1-Math.min(1,misRate))); gained=Math.round(gained*mult); }
      state.score+=gained; state.lines+=rows.length; state.level=Math.floor(state.lines/10)+1;

      if(state.level!==oldLevel){ playMusicForLevel(state.level); }

      popNext(); canHold=true;
      if(!ensureSpawnValid()) return;
      updateDisplay();
      if(tut.practiceMode && tspin) tutAdvance();
    });
  } else {
    popNext(); canHold=true;
    if(!ensureSpawnValid()) return;
    updateDisplay();
  }
}

/* ---------- Drops & Rotation ---------- */
function hardDrop(){ let dist=0; while(move(0,1)) dist++; if(dist>0){ state.score+=dist*HARD_POINT; roll.hard++; SND.drop(); } lockPiece(); }
function rotateCurCW(){ if(!state.cur) return; const r=srsRotateCW(state.cur); if(r.ok){ state.cur.shape=r.shape; state.cur.x=r.x; state.cur.y=r.y; state.cur.o=r.o; lastActionWasRotate=true; lockSince=null; SND.rotate(); updateDisplay(); } else { roll.mis++; } }

/* ---------- Gravity & Adaptive ---------- */
let slowMo=1; // classroom slow motion multiplier (>=1)
function gravityInterval(){ return Math.max(50, (INITIAL_SPEED - (state.level-1)*50) * slowMo); }

let adaptClock=0;
function adaptTick(dt){
  if(!state.adaptive||state.gameOver||state.paused) return; 
  adaptClock+=dt; if(adaptClock<12000) return; adaptClock=0;
  const age=(Date.now()-sessionStart)/1000, lpm=state.lines/Math.max(1,age/60);
  const misRate=roll.mis/Math.max(1,roll.locks), latency=roll.meanLatency||120;
  const comfort=(lpm/1.5)+(1-Math.min(1,misRate))+(120/Math.max(60,latency));
  if(comfort>=2.0){
    LOCK_DELAY=Math.max(200,LOCK_DELAY-40);
    state.queueSize=Math.max(3,state.queueSize-1);
  } else {
    LOCK_DELAY=Math.min(800,LOCK_DELAY+40);
    state.ghost=true;
    state.queueSize=Math.min(5,Math.max(3,state.queueSize)); // fixed clamp
  }
  optLock.value=String(LOCK_DELAY); drawNext();
}

/* ---------- Main loop ---------- */
let lastTs=performance.now();
function loop(ts){
  const dt=ts-lastTs; lastTs=ts;

  if(!state.paused && !state.gameOver){
    if(!animClearing){
      state.acc+=dt; const g=gravityInterval();
      while(state.acc>=g){
        state.acc-=g;
        if(!move(0,1)){
          const now=performance.now(); if(lockSince===null) lockSince=now;
          if(now-lockSince>=LOCK_DELAY){ lockPiece(); }
          break;
        }
      }
      if(state.downHeld && move(0,1)){ state.score+=SOFT_POINT; roll.soft++; }
      adaptTick(dt);
      updateDisplay();
    }
  }
  loopHandle=requestAnimationFrame(loop);
}

/* ---------- Metrics & CSV ---------- */
function markInput(){ const now=performance.now(), d=now-roll.lastInputAt; roll.lastInputAt=now; roll.inputs++; roll.meanLatency = roll.meanLatency===0 ? d : 0.9*roll.meanLatency + 0.1*d; }
function pushClassRow(status){
  const dur=Math.round((Date.now()-sessionStart)/1000);
  const row={ ts:new Date().toISOString(), status, seed:rngSeed, mode:clsMode.value, score:state.score, lines:state.lines, level:state.level, dur_s:dur,
    inputs:roll.inputs, latency_ms:Math.round(roll.meanLatency), soft:roll.soft, hard:roll.hard, mis:roll.mis, locks:roll.locks,
    tspins:stats.tspins, perfects:stats.perfects };
  const arr=JSON.parse(store.get(CLASS_KEY,"[]")); arr.push(row); store.set(CLASS_KEY,JSON.stringify(arr));
}
function exportCSV(){
  const arr=JSON.parse(store.get(CLASS_KEY,"[]"));
  if(!Array.isArray(arr)||arr.length===0){ alert("No session data to export yet."); return; }
  const cols=["ts","status","mode","seed","score","lines","level","dur_s","inputs","latency_ms","soft","hard","mis","locks","tspins","perfects"];
  const head=cols.join(",");
  const esc=v=>String(v).replaceAll('"','""');
  const body=arr.map(r=>cols.map(k=>`"${esc(r?.[k]??"")}"`).join(",")).join("\n");
  const blob=new Blob([head+"\n"+body],{type:"text/csv"});
  const url=URL.createObjectURL(blob);
  const a=document.createElement("a"); a.href=url; a.download="mc_tetris_classlog.csv"; a.click(); URL.revokeObjectURL(url);
}

/* ---------- Start / Pause / Over ---------- */
function computeSeedFromUI(){
  let seed;
  if(clsSeed.value==='daily' || optDaily.checked){ seed=dailySeed(); }
  else {
    const s=parseInt(clsSeed.value||optSeed.value,10);
    seed = Number.isFinite(s) ? s : Math.floor(Math.random()*1e9);
  }
  return seed>>>0;
}
function applyProjectorZoom(){
  const z=parseFloat(clsZoom.value)||1;
  CSS_CELL = Math.floor(32 * z);
  resizeCanvas();
  updateDisplay();
}
function applySlowMo(){ slowMo = Math.max(1, parseFloat(clsSlow.value)||1); }

function startGame(){
  LOCK_DELAY=+optLock.value;
  const adaptive=optAdaptive.checked, ghost=optGhost.checked, symbolic=optSymbolic.checked, qsize=+optQueue.value;

  rngSeed = computeSeedFromUI();
  state={ board:[], cur:null, hold:null, score:0, lines:0, level:1, paused:false, gameOver:false,
          acc:0, downHeld:false, gameStarted:true, adaptive, ghost, symbolic, queueSize:qsize };

  sessionStart=Date.now();
  stats.tspins=0; stats.perfects=0;
  roll.inputs=roll.soft=roll.hard=roll.mis=roll.locks=0; roll.meanLatency=0; roll.lastInputAt=performance.now();
  lastActionWasRotate=false;

  applyProjectorZoom();
  applySlowMo();

  makeBoard(); queue=newBag(); popNext(); drawHold(); drawNext(); if(!ensureSpawnValid()) return; updateDisplay();

  startModal.classList.add('hidden'); gameOverModal.classList.add('hidden');
  startBtn.classList.add('hidden'); pauseBtn.classList.remove('hidden');

  // classroom modes
  if(clsMode.value==='drill_tspin'){ loadTSpinDrill(); }
  if(clsMode.value==='drill_pc'){ loadPerfectClearDrill(); }

  playMusicForLevel(state.level);

  cancelAnimationFrame(loopHandle); lastTs=performance.now(); loopHandle=requestAnimationFrame(loop);

  // safety watchdog (quiet)
  clearTimeout(safetyTimerId);
  safetyTimerId=setTimeout(()=>{ if(state.gameStarted && !state.gameOver && !state.paused){ console.warn('Watchdog ok: long session.'); } }, 30000);

  // timed mode
  if(clsMode.value==='timed120'){
    setTimeout(()=>{ if(!state.gameOver){ gameOver(); alert('Time! 2-minute session complete.'); } }, 120000);
  }
}

function gameOver(){
  if(state.gameOver) return;
  state.gameOver=true; cancelAnimationFrame(loopHandle); clearTimeout(safetyTimerId); SND.over(); stopMusic();
  mustGet('finalScore').textContent=String(state.score);
  mustGet('finalLines').textContent=String(state.lines);
  mustGet('finalLevel').textContent=String(state.level);
  const secs=Math.max(1, Math.round((Date.now()-sessionStart)/1000));
  const lpm=(state.lines/(secs/60)).toFixed(1);
  mustGet('finalLPM').textContent=String(lpm);
  mustGet('finalTSpins').textContent=String(stats.tspins);
  mustGet('finalPCs').textContent=String(stats.perfects);
  gameOverModal.classList.remove('hidden'); pauseBtn.classList.add('hidden'); startBtn.classList.remove('hidden');
  pushClassRow('gameover');
}

function togglePause(){ 
  if(!state.gameStarted||state.gameOver) return; 
  state.paused=!state.paused; 
  if(state.paused){ pauseModal.classList.remove('hidden'); pauseBtn.textContent='RESUME'; stopMusic(); pushClassRow('pause'); }
  else { pauseModal.classList.add('hidden'); pauseBtn.textContent='PAUSE'; playMusicForLevel(state.level); lastTs=performance.now(); }
}

/* ---------- Drills ---------- */
const tut={practiceMode:false, step:0};
function loadTSpinDrill(){
  tut.practiceMode=true;
  makeBoard();
  for(let y=BOARD_HEIGHT-4;y<BOARD_HEIGHT;y++) for(let x=0;x<BOARD_WIDTH;x++){
    const leave=((y===BOARD_HEIGHT-3 && x===4) || (y===BOARD_HEIGHT-2 && (x===3||x===5)) || (y===BOARD_HEIGHT-1 && x===4));
    if(!leave) state.board[y][x]='color-J';
  }
  queue=['T','I','L','S','Z','J','O']; popNext(); state.cur.y=14; state.cur.x=4;
  drawHold(); drawNext(); updateDisplay();
}
function loadPerfectClearDrill(){
  tut.practiceMode=true;
  makeBoard();
  // simple PC pattern: two rows with gap to encourage neat fill
  for(let x=0;x<BOARD_WIDTH;x++){ state.board[18][x]='color-S'; if(x!==5) state.board[19][x]='color-S'; }
  queue=['I','O','T','L','J','S','Z']; popNext(); state.cur.y=0; state.cur.x=3;
  drawHold(); drawNext(); updateDisplay();
}
function tutAdvance(){ /* placeholder hook; already counted in scoring */ }

/* ---------- Keys ---------- */
const DEFAULT_KEYS={ left:'ArrowLeft', right:'ArrowRight', down:'ArrowDown', rotate:'ArrowUp', hard:'Enter', hold:'Shift', pause:'p' };
function loadKeys(){ return {...DEFAULT_KEYS, ...JSON.parse(store.get('mc_kb',"{}"))}; }
function saveKeys(map){ store.set('mc_kb',JSON.stringify(map)); }
let KEYS=loadKeys();

const kb = {
  modal: mustGet('keysModal'),
  left: mustGet('kbLeft'), right: mustGet('kbRight'), down: mustGet('kbDown'),
  rotate: mustGet('kbRotate'), hard: mustGet('kbHard'), hold: mustGet('kbHold'), pause: mustGet('kbPause'),
  save: mustGet('kbSave'), cancel: mustGet('kbCancel')
};
function openKeybinds(){ kb.left.value=KEYS.left; kb.right.value=KEYS.right; kb.down.value=KEYS.down; kb.rotate.value=KEYS.rotate; kb.hard.value=KEYS.hard; kb.hold.value=KEYS.hold; kb.pause.value=KEYS.pause; kb.modal.classList.remove('hidden'); }
kb.save.addEventListener('click',()=>{ KEYS={ left:kb.left.value||DEFAULT_KEYS.left, right:kb.right.value||DEFAULT_KEYS.right, down:kb.down.value||DEFAULT_KEYS.down, rotate:kb.rotate.value||DEFAULT_KEYS.rotate, hard:kb.hard.value||DEFAULT_KEYS.hard, hold:kb.hold.value||DEFAULT_KEYS.hold, pause:kb.pause.value||DEFAULT_KEYS.pause }; saveKeys(KEYS); kb.modal.classList.add('hidden');});
kb.cancel.addEventListener('click',()=> kb.modal.classList.add('hidden'));

document.addEventListener('keydown',(e)=>{
  if(!state.gameStarted){ if(e.key===' '||e.key==='Enter'){ e.preventDefault(); startGame(); } return; }
  if(state.gameOver){ if(e.key===' '||e.key==='Enter'){ e.preventDefault(); startGame(); } return; }
  const k=e.key;
  if(k===KEYS.left){ e.preventDefault(); if(state.cur){ move(-1,0); markInput(); updateDisplay(); } }
  else if(k===KEYS.right){ e.preventDefault(); if(state.cur){ move(1,0); markInput(); updateDisplay(); } }
  else if(k===KEYS.down){ e.preventDefault(); state.downHeld=true; markInput(); }
  else if(k===KEYS.rotate || k===' '){ e.preventDefault(); rotateCurCW(); markInput(); }
  else if(k===KEYS.hard){ e.preventDefault(); hardDrop(); markInput(); }
  else if(k===KEYS.hold || k==='c' || k==='C' || k==='Shift'){ e.preventDefault(); holdSwap(); markInput(); }
  else if(k.toLowerCase()===KEYS.pause.toLowerCase()){ e.preventDefault(); togglePause(); }
});
document.addEventListener('keyup',(e)=>{ if(e.key===KEYS.down) state.downHeld=false; });

/* ---------- Tutorial (short) ---------- */
const tutorialModal=mustGet('tutorialModal');
const tutBody=mustGet('tutBody');
const tutNext=mustGet('tutNext');
const tutPrev=mustGet('tutPrev');
const tutExit=mustGet('tutExit');

const slides = [
  { title:"Welcome", html:`<p>Controls: ← → move, ↓ soft drop, ↑/Space rotate, Enter hard drop, C/Shift hold, P pause.</p><p>7-bag randomizer, SRS kicks, lock delay, ghost piece enabled.</p>` },
  { title:"Classroom", html:`<p>Select <b>Mode</b>, <b>Lesson Seed</b>, <b>Projector</b> and <b>Slow Motion</b>, then START.</p><p>All sessions log to CSV via <b>EXPORT CSV</b>.</p>` },
  { title:"Drills", html:`<p><b>T-Spin Single</b> drill and a <b>Perfect Clear</b> starter are built in. Great for demos and assessment.</p>` }
];
let slideIdx=0;
function renderSlide(){ const s=slides[slideIdx]; tutBody.innerHTML=`<h3 style="margin-bottom:.4rem">${s.title}</h3><div class="tut-body">${s.html}</div>`; tutPrev.disabled=(slideIdx===0); tutNext.textContent=(slideIdx===slides.length-1)?'Finish':'Next'; }
function openTutorial(){ slideIdx=0; renderSlide(); tutorialModal.classList.remove('hidden'); }
function closeTutorial(){ tutorialModal.classList.add('hidden'); if(!state.gameStarted) startModal.classList.remove('hidden'); }
tutNext.addEventListener('click',()=>{ if(slideIdx<slides.length-1){ slideIdx++; renderSlide(); } else closeTutorial(); });
tutPrev.addEventListener('click',()=>{ if(slideIdx>0){ slideIdx--; renderSlide(); } });
tutExit.addEventListener('click',()=> closeTutorial());

/* ---------- Sharing / URL config ---------- */
function parseQuery(){
  const p=new URLSearchParams(location.search);
  if(p.has('mode')) clsMode.value=p.get('mode');
  if(p.has('seed')){ const s=p.get('seed'); if(s==='daily') clsSeed.value='daily'; else clsSeed.value=String(parseInt(s,10)||'daily'); }
  if(p.has('zoom')) clsZoom.value=String(Math.max(1, Math.min(1.5, parseFloat(p.get('zoom'))||1)));
  if(p.has('slow')) clsSlow.value=String(Math.max(1, Math.min(2, parseFloat(p.get('slow'))||1)));
  if(p.has('music')) optMusic.checked=(p.get('music')==='1');
  if(p.has('adaptive')) optAdaptive.checked=(p.get('adaptive')==='1');
}
function shareableURL(){
  const u=new URL(location.href);
  const p=u.searchParams;
  p.set('mode', clsMode.value);
  p.set('seed', clsSeed.value);
  p.set('zoom', clsZoom.value);
  p.set('slow', clsSlow.value);
  p.set('music', optMusic.checked? '1':'0');
  p.set('adaptive', optAdaptive.checked? '1':'0');
  u.search = p.toString();
  return u.toString();
}

/* ---------- Bindings ---------- */
document.addEventListener('DOMContentLoaded', ()=>{
  // buttons
  startBtn.addEventListener('click', (e)=>{ e.preventDefault(); startGame(); });
  startModalStartBtn.addEventListener('click', (e)=>{ e.preventDefault(); startGame(); });
  gameOverRestartBtn.addEventListener('click', (e)=>{ e.preventDefault(); startGame(); });
  startModalTutBtn.addEventListener('click', (e)=>{ e.preventDefault(); openTutorial(); });
  tutorialBtn.addEventListener('click', (e)=>{ e.preventDefault(); openTutorial(); });

  pauseBtn.addEventListener('click', togglePause);
  rotateBtn.addEventListener('click', ()=> rotateCurCW());
  dropBtn.addEventListener('click', ()=> hardDrop());
  holdBtn.addEventListener('click', ()=> holdSwap());
  exportBtn.addEventListener('click', ()=> exportCSV());

  // teacher tools
  btnBell.addEventListener('click', ()=> beep(880,0.15,0.05));
  btnResetLog.addEventListener('click', ()=>{ store.set(CLASS_KEY,'[]'); alert('Logs cleared.'); });
  btnCopyURL.addEventListener('click', ()=>{
    const url=shareableURL();
    navigator.clipboard?.writeText(url); alert('Shareable URL copied to clipboard.');
  });

  // behavior toggles
  optQueue.addEventListener('change', ()=>{ if(state){ state.queueSize=+optQueue.value; drawNext(); } });
  clsZoom.addEventListener('change', applyProjectorZoom);
  clsSlow.addEventListener('change', applySlowMo);

  // touch: use touchend to avoid 300ms delay
  [...document.querySelectorAll('.btn')].forEach(b=>{
    b.addEventListener('touchend', e=>{ e.preventDefault(); b.click(); }, {passive:false});
  });

  // theme/background (debounced) – we keep gradient; no external fetches
  const debouncedPaint = debounce(updateDisplay, 120);
  window.addEventListener('resize', debouncedPaint);

  // parse config from URL for classrooms
  parseQuery();

  // initial board
  state={ board:[], cur:null, hold:null, score:0, lines:0, level:1, paused:true, gameOver:false, acc:0, downHeld:false, gameStarted:false, adaptive:true, ghost:true, symbolic:false, queueSize:+optQueue.value||5 };
  makeBoard(); drawHold(); drawNext(); resizeCanvas(); drawBoard();
  startModal.classList.remove('hidden');

  // auto-pause on tab switch (classroom courtesy)
  document.addEventListener('visibilitychange', ()=>{
    if(document.hidden && state.gameStarted && !state.paused && !state.gameOver) togglePause();
  });
});

/* ---------- Exported for drills (no globals beyond this) ---------- */
window.openTutorial = openTutorial;
</script>
</body>
</html>
